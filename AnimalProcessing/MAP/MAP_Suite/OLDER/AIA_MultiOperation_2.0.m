% Advanced_Image_Analysis (AIA)
%
% Version 2
% Stephane Rigaud
%
% Script containing all necessary info required to run Operation over Animal
% and is aimed to extract most of those information respectively from the 
% different AIA_Info of each animals.
%
% definitions and conventions
% Quantities : EG, ED, EA, I, V, S, ... ; shortened into Q
% Processes  : AOS, TA, SM, ... ;         shortened into P
% Operations : AOA, DOA, ... ;            shortened into O
%
% With exception of AOA and DOA, all operations run on single and average
% movies. To run a single movie, one must leave the Oname empty.
% Single animal operation can only be done on quantities from the same
% process (e.g. cannot do EG and S on the same run)
%
% ACHTUNG! POA can involve 2 different animal. The corresponding backup and
% plot will be named by the secondary animal, but saved in the primary
% animal folder.
%
% ACHTUNG again! COQ on single animal will directly update the raw backup
% generated by Boris framework

% TODO:
% * finishing integrating COQ quantities in the other operations
% * GUI interface for selecting region in LTA
% * normalisation of tensor norm in LTA (needed?)
% * Clean and add Tensor Correlator
% * Test all the possible options (should work fine ... I guess)


%% DO NOT MODIFY
% Sanity cleaning of Matlab
clear all; close all; clc;
% Flag preventing AIA_parameters to run other programs
AIA_call = 1;


%% Operation Name (Oname) Selection
% Boolean in order to select which Operation will be run ;
% NB: /!\ only run one at a time, otherwise the planete will implode

AOA = 1;               % Average Over Animal (single animal only)
DOA = 0;               % Difference Over Animal (averaged animal only)
COQ = 0;               % Calcul Over Quantities
POA = 0;               % Projection Over Animal
LTA = 0;               % Local Time Analysis

TC  = 0;               % Tensor Corelator (in progress)

% Global output path. All the calculated output will be saved in a file
% structure located at this specified path.
PathName = 'D:\BigMovies\AOA_WT_stress_fibers';
AIAFolderName = 'C:\Users\Boris\ownCloud\Matlab\AIA_infos'; % path to the folder containing the AIA_info_X


%% Common Parameters
% plot process parameters
PLOT.plot = 0;                   % plot the selected quantities (Qname)
PLOT.print = 1;                  % print the plot
PLOT.significance = 0;           % plot significance
PLOT.SignOpacityMap = [0.5 0.5]; % significance opacity [iso dev]
PLOT.extension = 'png';          % plot image type (png | svg)
PLOT.resolution = 300;           % plot resolution
PLOT.boxSize = [122 128/2]/0.322; % JESUS
% PLOT.boxSize = [256 256];        % box size of the average grid
PLOT.macrocaetes = 1;            % plot macrocaetes position


%% Time information (must be correctly filled)
% animalTimeWidth   = 20;
% animalTimeOverlap = 0;  % to make a plot at every single frame
animalTimeWidth   = 2;
animalTimeOverlap = 0.96;  % to make a plot at every single frame
% multiTimeStart    = '00h00';
% multiTimeStop     = '20h00';
multiTimeStart    = '12h00';
multiTimeStop     = '32h00'; % 28 for wt3


%% AOA - Average over Animals
if AOA
    % This process calculate the average of N individual (N can be 1) together.
    % The spatial and temporal average should be the same between the animal
    % in order to average them together (see AOT)
    
    % Specify the list of all animals name that will be use in the generation of the average grid
    % NB: The list should contain all animal that will be compared and not only the animal to be ploted
    % by default: provide all the possible animals
    
    
%     All_Animals = {'wt3'};
    
%     All_Animals = { 'BIG_1' ; 'BIG_5' ; 'BIG_6' ; 'BIG_N5m' ; 'BIGwt2r' ; 'BIGwt2l'};
    All_Animals = { 'TRBL1' ; 'TRBL4' ; 'TRBL7' ; 'TRBL9' ; 'TRBL8l'  ; 'TRBL8r'  }; % animal name list
    
    
%    Animals = {'wt3'};
%     Animals = { 'BIG_1' ; 'BIG_5' ; 'BIG_6' ; 'BIG_N5m' ; 'BIGwt2r' ; 'BIGwt2l'};
%     Animals = { 'BIG_1' ; 'BIG_5' ; 'BIG_6' ; 'BIG_N5m' ; 'BIGwt2r' ; 'BIGwt2l'};
    Animals = { 'TRBL1' ;'TRBL4' ; 'TRBL7' ; 'TRBL9' ; 'TRBL8l' ; 'TRBL8r'};


    % ESCARGOT FULL 12 APF
    % All_Animals = {'esgGfp_12apf_1';'esgGfp_12apf_2';'esgGfp_12apf_3';'esgGfp_12apf_4'};  
    % Animals = {'esgGfp_12apf_1';'esgGfp_12apf_2';'esgGfp_12apf_3';'esgGfp_12apf_4'}; 
    
    
    % ESCARGOT FULL 24 APF
    % All_Animals = {'esgGfp_24apf_1';'esgGfp_24apf_2';'esgGfp_24apf_3'};
    % Animals = {'esgGfp_24apf_1';'esgGfp_24apf_2';'esgGfp_24apf_3'}; 
    
    genericName = 'meanTRBL';
%     genericName = 'meanWT3int';
    
    %%% Values
    % Pname = | SM ; VMM ; AOS ; TA | ...
    % Qname = | EA ; EG ; ED ; mI ; etc. | ...
    % QPlot_type = | dev+/- ;  split+/- ; merge |
        
%     Pname = 'AOS';                                             % Process name
%     Qname = {'M' 'Rho' };  % Quantities name
    Pname = 'TA';
    Qname = {'EA';'ER';'ES';'ED';'EJ';'EN';'EF';'EG'};  % Quantities name
%     Qname = {'EG' 'ED' 'ER' 'EA' 'ES' 'Phi'};  % Quantities name
%     QplotType = 'dev+';                                       % Plot Type
%     QplotType = 'circle';
    QplotType = 'split+';
    
        
end


%% DOA - Difference over Animals
if DOA
    % This process calculate the difference between two individual.
    % In this case, an individual is the output of a Process (AOA, DOA, COA, other)
    % In the current state, both individual are coming from the same Process (AOA - AOA, DOA - DOA, but no AOA - DOA)
    % As this is a simple A - B operation, both individual must have the same spatial and temporal size, with same overlap
    
    Oname = 'AOA'; % Operation name
    
    % Animal 1 minus Animal 2
    % The name of the output animal will be A1-A2
    Animal  = { 'meanWT3' ; 'meanWT3int'};
    
    
    %%% Values
    % Pname = | SM ; VMM ; AOS ; TA | ...
    % Qname = | EA ; EG ; ED ; mI ; etc. | ...
    % QPlot_type = | dev+/- ;  split+/- ; merge |
    
    Pname = 'TA';                                             % Process name
%     Qname = {'gradUS' };
    Qname = {'EA';'ER';'ES';'ED';'EJ';'EN';'EF';'EG'};  % Quantities name
    QplotType = 'split+';                                     % Plot Type
    % QplotType = 'circle';
    
    PLOT.Qparameters = 1;
    % if Qparameters is off, use the following parameters for the plot
    Qcolor = [0.3 0.5 0.5];
    Qunits = 'h^{-1}';
    Qsr = 6e3;
    Qsrbar = 1e-2;
%     Qsr = 4e3;
%     Qsrbar = 2e-2;
    QKillTr = 0;
end


%% COQ - Calcul over Quantities
if COQ
    
    % COQ allow to perform simple mathematical operation, such as substractio
    % or addition, on quantities or an animal.
    % The difference with DOA is that all operation are performe between
    % quantities of the same animal, e.g. A.EG - A.ED
    % The results is saved in the animal backup as a new quantity
    
    
    Oname = '';% Operation name, single animal process if empty
    Animal = 'BIGwt2';
    
    % Quantities concerned by the operation
    % A - B, A + B, ...
    % A and B should be from the same process
    QnameA = 'EG';
    QnameB = 'ED';  
   
    CalculType = 'minus'; % choose between 'minus', 'plus'
    
    QplotType = 'dev+';
end


%% POA - Projection over Animals
if POA 
    
    % POA projects the quantity A on the unitary tensor of the quantity B
    % A and B can be from different animal with different temporal averaging
    % However their grid must be identical
    
    % type of projection to be plotted in maps (only one at a time)
    tagPlot = 'd';  % choose between 'd', 'i', 'do' for, respectively deviator, isotropic, orthogonal deviator
    
    % project this:
    Oname = '';              % Operation name (AOA...), leave empty for single animal processing
%     Animal ='meanWT_grid26h';
%     Animal = 'BIGwt2';
%     Animal = 'R23';
    Animal = 'TRBL8';
    Qname = {'EG';'ES';'ER';'ED';'EA'}; % list of quantities to be calculated
    
    % ONTO this:
    % NB: if uOname and uAnimal are empty, we use the Oname and Animal from the projection value
    uOname = '';             % Operation name (AOA...), leave empty for single animal processing
    uAnimal = 'TRBL8';
%     uAnimal = 'meanWT_grid26h';
%     uAnimal = 'BIGwt2';       
    uTimeWidth = 20;    % time average of the projector animal
    uTimeOverlap = 0; % time overlap of the projector animal
    uQname = 'EG';      % quantity used for projector 
    
    Qunits = 'h^{-1}';
    Qsr    = 50*10^1;
    Qsrbar = 0.1;
    
end


%% LTA - Local Time Analysis
if LTA
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    singleAnimal = true;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    Oname = 'POA';         % Operation name (AOA, POA...)
    Animal = 'TRBL8';
%     Animal = 'R23';     % Animal name
%     Animal ='meanWT_grid26h';
%     Animal = 'BIGwt2';     % Animal name
    Qname = {'EGdotEG','ERdotEG','ESdotEG','EDdotEG','EAdotEG'};
%     Qname = {'EG','ED','ER','ES','EA','M','I','Rho'};
%     Qname = {'EDdotEG','ERdotEG','ESdotEG','EAdotEG'}; % Quantity list to be ploted
%     Qname = {'ID2'};
    
    % range of zone xy coordinates (not ij!!!) to be included (those coordinates start at [1 1]):
    Qareas = {[2 2; 2 2]}; % {[xMin xMax ; yMin yMax]} of box coodinates
%     Qareas = {[1 1; 1 1]}; % {[xMin xMax ; yMin yMax]} of box coodinates
%     Qareas = {[2 2; 1 1]}; % {[xMin xMax ; yMin yMax]} of box coodinates
%     Qareas = {[2 2; 3 3]}; % {[xMin xMax ; yMin yMax]} of box coodinates
    % NB: Examples: {[1 6; 1 5]} will process all boxes from (1,1) to box (6,5) (in xy coordinates)
    % NB: Examples: {[6 6; 5 5]} will ONLY process the box (6,5) (in xy coordinates)
    
%     CropRegionGrid = Qareas{z};
%     Quantity(CropRegionGrid(2,1):CropRegionGrid(2,2),CropRegionGrid(1,1):CropRegionGrid(1,2),:,:);
%     filename = [ '(' num2str(CropRegionGrid(1,1)) ',' num2str(CropRegionGrid(2,1)) ')(' num2str(CropRegionGrid(1,2)) ',' num2str(CropRegionGrid(2,2)) ')'];
    
    % Axis range, leave empty for automatic range selection, otherwise like this: {[400 410]}
%     Qrange = {};
%     Qrange = {0.07*[-1 1]}; 
    Qrange = {0.12*[-1 1]};     % R23
    
    % if projection is involved, specify ONTO what here (must have been calculated before in POA):
    uAnimal = 'TRBL8';
%     uAnimal = 'R23';
%     uAnimal ='meanWT_grid26h';
%     uAnimal = 'BIGwt2';
    uTimeWidth = 20;
    uTimeOverlap = 0;
    
    delta_t = 5;
    
    Normalisation = ''; % normalisation over region, animal, or no normalisation (none)
end


%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% ADVANCE STUFF %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% modify at your hown risk %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Format, resolution, and extention
printFormat     = ['-d' PLOT.extension];
printResolution = ['-r' num2str(PLOT.resolution)];
imageExtension  = ['.'  PLOT.extension];

% Store time information in struct more simple managment
TIME.animalTimeOverlap = animalTimeOverlap;
TIME.animalTimeWidth   = animalTimeWidth;
TIME.multiTimeStart    = multiTimeStart;
TIME.multiTimeStop     = multiTimeStop;

CustomColors;       % defines usual set of colors
AllQsColorsUnits;   % associate quantities with specific colors

% display parameters to be used during plot
minimalInfoDisplay = false;
% minAEV = 0.0001;
fontSize = 20;
EVstyles = {'-' '--'};       % ONLY relevant for "merged" display type: styles to display ellipse axes representing tensor eigenvalues (default {'-' ':'})
pointSize = 2;
signOpacities = [0.7 0.3];   % ONLY relevant for "split+/-" and "circle" display types: specifies opacity of positive(white) and negative(black) disks, respectively.
lineWidth = 1.5;             % for circle, bars and ellipses (1.5 ok with BIG movies)
gridDisplay = false;         % Lagrangian grid ALWAYS displayed (6.0)
gridColor = black;
gridLineWidth = 0.5;        % only matters for Egrid, Lgrid thickness specified in LGridPlotter
imageFading = 0.6;
scaleBarWidth = 1;

% Scale values according to the information to be ploted
sr_AOS        = { 4e2 ; 50 ;0.8*[1 3]; 100 ; [4 30] };   % sets ratio setting size of ellipses or bars in tensor representation for M,I. % 2 hours
% sr_AOS        = { 5e2 ; 50 ;[1 3]; 100 ; [4 30] };   % sets ratio setting size of ellipses or bars in tensor representation for M,I. % 14h/20h hours
srbar_AOS     = [ 0.1 ;  2 ; 50 ;  1  ;    10  ];   % scale bar lengths for each contribution
killtrace_AOS = [  0  ;  0 ;  0 ;  1  ;     1  ];   % Will set average compartment trace to 0 in the plots (mean isotropic part = 0). Choose this when tensors are known up to an additive constant
% contributions   Rho    I    M    V       CD

sr_SM        = { 1500 ; 1000 ; 1000 ; 1000 };
srbar_SM     = [  0.1 ; 0.05 ; 0.05 ; 0.05 ];
killtrace_SM = [    1 ;    1 ;    1 ;    1 ];
% contributions     S     SP     ST      P

% eLife paper:
%-----------------------------------------------------------------------------------------------------------------------------------------
% sr_TA        = {  4e3 ;  2e3 ;  4e3 ;  8e3 ;  2e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 };  % ISO average 14h/20h
% sr_TA        = {  4e3 ;  4e3 ;  4e3 ;  8e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 };  % DEV average 14h/20h
% srbar_TA     = [ 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ; 2e-2 ];
%-----------------------------------------------------------------------------------------------------------------------------------------

%%% 14h/20h averages:
%-----------------------------------------------------------------------------------------------------------------------------------------
% sr_TA        = {  4e3 ;  1.5e3 ;  4e3 ;  8e3 ;  1.5e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 ;  4e3 };  % ISO average 14h/20h
sr_TA        = 6e3; sr_TA = num2cell(sr_TA*ones(15,1));  % DEV average 14h
% sr_TA        = 4e3; sr_TA = num2cell(sr_TA*ones(15,1));  % DEV average 14h
srbar_TA     = 2e-2*[ 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ];
%-----------------------------------------------------------------------------------------------------------------------------------------
%%% 2h averages:
%-----------------------------------------------------------------------------------------------------------------------------------------
% sr_TA        = {  6e3 ;  [1.5e3 6e3] ;  6e3 ;  6e3 ;  [1.5e3 6e3] ;  6e3 ;  6e3 ;  6e3 ;  6e3 ;  6e3 ;  6e3 ;  6e3 ;  6e3 ;  6e3 ;  6e3 };  % ISO&DEV average 2h
% srbar_TA     = 2e-2*[ 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ];
% STEPHANE:
% sr_TA        = 2e3; sr_TA = num2cell(sr_TA*ones(15,1));  % DEV average 2h
% sr_TA        = {  2e3 ;  0.5e3 ;  2e3 ;  2e3 ;  0.5e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 };  % ISO average 2h
% sr_TA        = {  2e3 ;  [0.5e3 2e3] ;  2e3 ;  2e3 ;  [0.5e3 2e3] ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 ;  2e3 };  % ISO&DEV average 2h
% srbar_TA     = 5e-2*[ 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ; 1 ];
%-----------------------------------------------------------------------------------------------------------------------------------------

killtrace_TA = [    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ;    0 ];
% contributions     G      S      R     Ds      D      A      N      F      J     Jb     DM      U     G*    PSI   PhiU

sr_VM        = { 10 ; 2000 ; 2000 };
srbar_VM     = [  1 ; 0.02 ; 0.02 ];
killtrace_VM = [  0 ;    0 ;    0 ];
% contributions   U  gradUS  gradUAS

sr_GEP        = {  150 };
srbar_GEP     = [  0.5 ];
killtrace_GEP = [  0 ];
% contributions   ID

%% AOA - Advance
if AOA
    disp('Load Animals AIA Info for each animal ...')
    
    % Values to be meaned
    % NB: possibility to inverser problematique, values to not mean
    %     advantage to be more generic to any future Process. beware of specific cases such as mCD
    % TODO: Update the list with the new value name from Boris
    %AOS_list = { 'AreaRatios' ; 'Rho' ; 'I'      ; 'M'       ; 'V'      };
    %SM_list  = { 'AreaRatios' ; 'S'   ; 'SP'     ; 'ST'      ; 'P'      };
    %VM_list  = { 'AreaRatios' ; 'U'   ; 'gradUS' ; 'gradUAS' ; 'Ianais' };
    %TA_list  = { 'AreaRatios' ; 'EG'  ; 'ES'     ; 'ER'      ; 'EDs'    ; 'ED' ;  'EA' ; 'EN' ; 'EF' ; 'EJ' ; 'EJb' ; 'EDM' ; 'E' ; 'EPSI' ; 'Phi' ; 'errorPs' ; 'errorDnPs' ; 'RConds' };
    rejectList = {'xywh';'size';'overlap';'centroids';'ULCs'; 'fullImage';'color';'lineWidth';'coordinates'; 'TimeArray';'FrameArray'};
    
    backupPathList = {}; % initialisation for list of path to the mean backup
    macroCoord = NaN(14,2,length(All_Animals));
    
    % loading parameters and data for each animal using their respective AIA_info_
    mean_GRID_specs = cell( size(All_Animals,1), 1 );
    for n = 1:length(All_Animals)
        
        disp(All_Animals{n});
        
        % If it is an animal to be processed in the mean
        if ismember( All_Animals{n}, Animals )
            [~,cpt] = ismember( All_Animals{n}, Animals ); % for the AOS multichannel
            [GRID backupPath AOSvariable, RAW] = SingleAnimalLoader(AIAFolderName, All_Animals{n}, Pname, TIME, true );
            
            % Store backup path to be loaded later
            backupPathList = [backupPathList backupPath];
            
            % THIS IS NOT WORKING -----------------------------------------
            % Store AOS multichannel name, to be used later (compatibility)
%             if strcmp(Pname,'AOS') 
%                 AOS_tmp_name{cpt,:} = AOSvariable.AOS_tmp_name;
%                 AOS_dif_name{cpt} = AOSvariable.AOS_dif_name;
%                 AOS_sub_name = AOSvariable.AOS_sub_name;
%             end
            % THIS IS NOT WORKING -----------------------------------------
            
%             eval(['GRID_' Pname '_' All_Animals{n} '= load(backupPath);']);
            load(backupPath)
            
            %%% load macrocaete position
            %--------------------------------------------------------------
            nbMacro = 8;
            if strcmp(RAW.halfNotum,'b')
                nbMacro = 14;
            end
            macroCoord(1:nbMacro,:,n) = LandmarkLoader(RAW.rawPathFolder, All_Animals{n}, RAW.halfNotum);
            coefXY = PLOT.boxSize ./ RAW.boxSize;
            macroCoord(:,1,n) = (macroCoord(:,1,n) - RAW.xyStart(1)) .* coefXY(1);
            macroCoord(:,2,n) = (macroCoord(:,2,n) - RAW.xyStart(2)) .* coefXY(2);
            %--------------------------------------------------------------
        else
            [GRID, ~, ~, ~] = SingleAnimalLoader(AIAFolderName, All_Animals{n}, Pname, TIME, false );
        end
        
        % save the grid in the mean grid structure
        mean_GRID_specs{n} = GRID;
        gridOverlap = GRID.overlap;
    end
    
    % Complete the AOS list in the case of multiple signal
%     if strcmp(Pname,'AOS') % THIS IS NOT WORKING
%         if exist('AOS_tmp_name','var')
%             
%             n_raw = length( filenameRaw );
%             Filename_Raw_mod = cell(n_raw,1);
%             ind_raw_polarity = find(polarityRawImages); % index of signal, [1 2 .... n]
%             if length(Animals) == 1
%                 AOS_sub_name_temp = { intersect( AOS_tmp_name{1,1}, AOS_tmp_name{1,2}, 'stable' ) ; ...
%                     intersect( AOS_tmp_name{1,1}, AOS_tmp_name{1,2}, 'stable' ) };
%                 [~,index1] = ismember( AOS_sub_name_temp{1}, AOS_tmp_name{1,1} );
%                 [~,index2] = ismember( AOS_sub_name_temp{2}, AOS_tmp_name{1,2} );
%                 AOS_sub_name = { AOS_tmp_name{1,1}(1:index1-1) ; AOS_tmp_name{1,2}(1:index2-1) };
%                 AOS_list = [AOS_list ; ...  % completes AOS_list with "CD_"signal names
%                     ['CD_' AOS_sub_name{1} ]; ['CD_' AOS_sub_name{2} ]];
%             else
%                 AOS_sub_name = { intersect( AOS_tmp_name{1,1}, AOS_tmp_name{2,1}, 'stable' ) ; ...
%                     intersect( AOS_tmp_name{1,2}, AOS_tmp_name{2,2}, 'stable' ) };
%                 AOS_list = [ AOS_list ; ...  % completes AOS_list with "CD_"signal names
%                     ['CD_' AOS_sub_name{1} ]; ['CD_' AOS_sub_name{2} ]];
%             end
%             
%         end
%     end
    
    % Loads macrocaetes positions
%    if ~isempty(macrocaete_folder)
%         load(macrocaete_folder);
%         nbMacro = size(Landmarks_output_R,1)-1;
%         macroCoord = NaN(size(Animals,1),2,nbMacro);
%         macrocaetes = NaN(5,nbMacro);
%         for a=1:size(Animals,1)
%             idx = strmatch(Animals{a}, char(Landmarks_output_R{1,:} ));
%             for m=1:nbMacro
%                 macroCoord(a,1,m) = Landmarks_output_R{m+1,idx}(1);
%                 macroCoord(a,2,m) = Landmarks_output_R{m+1,idx}(2);
%             end
%         end
%         for m=1:nbMacro
%             avg = nanmean(macroCoord(:,:,m),1);
%             var = nanstd(macroCoord(:,:,m));
%             if length(var) ~= 1
%                 r = atan2 (max( var(1), var(2)) , min( var(1), var(2)) );
%                 r = rad2deg(r);
%                 macrocaetes(:,m) = [avg(1) avg(2) var(1) var(2) r];
%             else
%                 r = 1;
%                 macrocaetes(:,m) = [avg(1) avg(2) var(1) var(1) r];
%             end
%             
%         end
        macrocaetes = NaN(5,14);
        macrocaetes(1:2,:) = nanmean(macroCoord,3)';
        DISPLAY.macrocaetes = macrocaetes;
    %end
    
    % Output Path
    OutputPathName = [PathName filesep 'AOA_' genericName '_' num2str(animalTimeWidth) 'h_olap_' num2str(animalTimeOverlap) ];
    
    % Run main process
    disp('Start AOA Processing ...')
    Average_Over_Animals
    disp('Done ... !')
end


%% DOA - Advance
if DOA
    
    DOAname = [Animal{1} '-' Animal{2}];
    
    disp('Load corresponding backup ...')
    
    LoadedBackup = cell(1,2);
    if isempty(Oname)
        
        disp('ERROR: DOA cannot work on raw animal because of grid correspondances.')
        disp('TIPS : Do a fake average of the animal for fixing the grid issue.')
        
        %         % animal 1
        %         [GRID backupPathList AOSvariable] = SingleAnimalLoader(AIAFolderName, Animal{1}, Pname, TIME, true );
        %         disp(backupPathList)
        %         load(backupPathList);
        %         LoadedBackup{1} = eval(['GRID_' Pname '_' Animal{1}]);
        %
        %         % animal 2
        %         [GRID backupPathList AOSvariable] = SingleAnimalLoader(AIAFolderName, Animal{2}, Pname, TIME, true );
        %         disp(backupPathList)
        %         load(backupPathList);
        %         LoadedBackup{2} = eval(['GRID_' Pname '_' Animal{2}]);
        
    else
        
        % animal 1
        disp([PathName filesep Oname '_' Animal{1} '_' num2str(animalTimeWidth) 'h_olap_' num2str(animalTimeOverlap) filesep Oname '_backup']);
        LoadedBackup{1} = load( [PathName filesep Oname '_' Animal{1} '_' num2str(animalTimeWidth) 'h_olap_' num2str(animalTimeOverlap) filesep Oname '_backup'] );
        
        % animal 2
        disp([PathName filesep Oname '_' Animal{2} '_' num2str(animalTimeWidth) 'h_olap_' num2str(animalTimeOverlap) filesep Oname '_backup']);
        LoadedBackup{2} = load( [PathName filesep Oname '_' Animal{2} '_' num2str(animalTimeWidth) 'h_olap_' num2str(animalTimeOverlap) filesep Oname '_backup'] );
        
    end
    
    
    % output folder path
    OutputFolderName = [PathName filesep 'DOA_' DOAname '_' num2str(animalTimeWidth) 'h_olap_' num2str(animalTimeOverlap) ];
    
    %     if PLOT.error %%% ????????
    %         disp(['We are calculating an error, we load the std from the first input: ' Animal{1}]);
    %         load([PathName filesep Oname '_' Animal{1} '_' num2str(animalTimeWidth) 'h_olap_' num2str(animalTimeOverlap) filesep Oname '_stdMAP']);
    %     end
    
    disp('Start DOA processing ...')
    
    Difference_Over_Animals;
    
    disp('Done ... !')
end


%% COQ - Advance
if COQ
    
    disp('Loading corresponding backup ...')
    if isempty(Oname)
        PLOT.significance = 0;
        PLOT.macrocaetes = 0;
        Pname = GetPname(QnameA);
        [~, backupPathList, ~, RAW] = SingleAnimalLoader(AIAFolderName, Animal,  'AOT',  TIME,  true );
        BACKUP = load( backupPathList );
        [OutputPath,backupPathName,~]  = fileparts(backupPathList);
        backupName = ['GRID_' Pname '_' Animal];
    else
        InputPathName  = [PathName filesep Oname '_' Animal '_' num2str(TIME.animalTimeWidth) 'h_olap_' num2str(TIME.animalTimeOverlap) ];
        BACKUP = load( [InputPathName filesep Oname '_backup'] );
        OutputPath = [InputPathName ];
        backupName = [Oname '_backup']; 
        backupPathName  = [Oname '_backup'];
    end
    
    disp('Start Processing ...')
    Calcul_Over_Quantities;
    disp('Done ... !')
end


%% POA - Advance
if POA
    
    tagTensor = {'i';'d';'do'};
    tagProjectionTime = [strrep(num2str(uTimeWidth),'.','') '_' strrep(num2str(uTimeOverlap),'.','')];
    
    QplotType = 'circle';
    QKillTr = 0;
    
    Pname  = GetPname(Qname{1});
    uPname = GetPname(uQname  );
    
    uTIME = TIME;
    uTIME.animalTimeWidth = uTimeWidth;
    uTIME.animalTimeOverlap = uTimeOverlap;
    
    if isempty(Oname)
        
        % projection is a single animal: 
        % - Animal must be the same as uAnimal
        % - Oname and uOname must be empty
        % - Qname can be different than uQname
        
        uOname = '';
        uAnimal = Animal;
        PLOT.significance = false;
        
        [~, backupPathList, ~, RAW] = SingleAnimalLoader(AIAFolderName, Animal,  'AOT',  TIME, true );
        [~, ubackupPathList, ~, ~]  = SingleAnimalLoader(AIAFolderName, uAnimal, 'AOT', uTIME, true );
        
        disp( 'Loading projection backup ...' );
        disp( backupPathList );
        BACKUP = load( backupPathList );
        
        disp( ['Loading projector backup ...' uQname] );
        disp( ubackupPathList );
        TEMPBACKUP = load( ubackupPathList );
        eval( ['B = TEMPBACKUP.' uQname ';'] );
        
        animalProjectionFolder = [Animal '_' num2str(TIME.animalTimeWidth) 'h_olap_' num2str(TIME.animalTimeOverlap)];
        
%         tempSubFolder = fileparts(backupPathList);
%         gridAnimalFolder = fileparts(tempSubFolder);
%         rawPathFolder = fileparts(fileparts(fileparts(tempSubFolder)));

    else
        
        % projection is an averaged animal: 
        % - check if uAnimal is specified, else uAnimal = Animal
        % - check if uOname is specified, else uOname  = Oname
        % - Qname can be different than uQname
        
        if isempty(uAnimal), uAnimal = Animal; end
        if isempty(uOname),  uOname  = Oname;  end
        
        animalProjectionFolder = [Oname  '_' Animal  '_' num2str(TIME.animalTimeWidth)  'h_olap_' num2str(TIME.animalTimeOverlap) ];
        animalProjectorFolder  = [uOname '_' uAnimal '_' num2str(uTIME.animalTimeWidth) 'h_olap_' num2str(uTIME.animalTimeOverlap)];
        
        disp( 'Loading projection backup ...' )
        disp( [PathName filesep animalProjectionFolder filesep Oname '_backup'] );
        BACKUP = load( [PathName filesep animalProjectionFolder filesep Oname '_backup'] );
        
        disp( ['Loading projector value ...' uQname] )
        disp( [PathName filesep animalProjectorFolder filesep Oname '_backup'] );
        TEMPBACKUP = load( [PathName filesep animalProjectorFolder filesep Oname '_backup'] );
        eval( ['B = TEMPBACKUP.' uQname ';'] );
        
    end
    
    outputPath = [PathName filesep animalProjectionFolder];
    
    disp('Start POA processing ...')
    Projection_Over_Animal;
    disp('Done ... !')
end


%% LTA - Advance
if LTA
    
    
    tagTensor = {''};
    tagProjection = '';
    tagBackup = 'backup';
    if strcmp(Oname,'POA')
        tagTensor = {'_d'; '_i'; '_do'};
        tagProjection = ['_' strrep(num2str(uTimeWidth),'.','') '_' strrep(num2str(uTimeOverlap),'.','')];
        tagBackup = uAnimal;
    end
    backupName = [Oname '_' tagBackup tagProjection];
    backupPathName = [Oname '_' tagBackup tagProjection];
    
    if singleAnimal
        
        if strcmp(Oname,'POA')
            backupPathList = [PathName filesep Animal '_' num2str(TIME.animalTimeWidth) 'h_olap_' num2str(TIME.animalTimeOverlap)];
            backupPathList = [backupPathList filesep backupPathName ];
        else
            Pname = GetPname(Qname{1});
            [~, backupPathList, ~, RAW] = SingleAnimalLoader(AIAFolderName, Animal,  'AOT',  TIME,  true );
            backupName = ['GRID_' Pname '_' Animal];
        end
        
        OutputPath = fileparts(backupPathList);
        
        disp( 'Loading backup ...' );
        disp( backupPathList );
        BACKUP = load( backupPathList );
        
        disp('Start LTA processing ...')
        Local_Time_Analysis;
        disp('Done ... !')
        
    else
        
        if strcmp(Oname,'DOA')
            InputPathName = [PathName filesep 'DOA_' Animal '_' num2str(TIME.animalTimeWidth) 'h_olap_' num2str(TIME.animalTimeOverlap)];
        else
            InputPathName = [PathName filesep 'AOA_' Animal '_' num2str(TIME.animalTimeWidth) 'h_olap_' num2str(TIME.animalTimeOverlap)];
        end
        
        backupPathList = [InputPathName filesep backupPathName];
        
        OutputPath = fileparts(backupPathList);
        
        disp( 'Loading backup ...' );
        disp( backupPathList );
        BACKUP = load( backupPathList );
        
        disp('Start LTA processing ...')
        Local_Time_Analysis;
        disp('Done ... !')
    end
    
    
    
    
end

