% CellPatchTracking (CPT)
%
% "AIA_parameters" (7.1+) now creates a grid (defined in AIA_info) that defines patches of cells to be tracked
% between "startFrame" and "finalFrame".
%
% NB: FL cells are ALL cells except grid core cells AND INITIAL image border cells. Then, those cells are
% tracked over time (including offspring) and "gridAllNonBorderRNs" becomes larger than borderRNs, as additional border
% cells can arise.
%
% NB**: core cells in compartement that transiently become FL or Border will be reintegrated in their initial patch when
% they are back to being core again (only properly supported in 3.5+). This has always been treated similarly in TA.
%
% NB**: SO FAR "TensorAnaysis" USES "MakeOffspring" TO GENERATE **ALL POSSIBLE OFFSPRING**, THIS PROGRAM DOESN'T!! =>
%       may be some adjustments required in TA
%
% NB: NOT removing coalesced cells belonging to several grid compartments because this happens normaly when grid are
%     overlapping
%
% NB: the list of ANVS in each grid compartments is updated at each iteration by comparison with "Correspondence" => no
%     need to remove divided or disappeared cells.
%
% NB: in "cloneTracking" mode, *1st* COLUMNS of cell arrays in backups correspond to (FILTERED) CLONE, *2nd* COLUMNS WILL
% contain WT parts mirroring clone parts (% midline)
%
version = '3.33'; % created from "LagrangianGrid" version 2.15
% Boris Guirao


%% Display info %%

program = 'CPT';
Today = datestr(now,29);
When = datestr(now,15);

% Moved up 3.16
disp(' '); disp(' ');
disp([program ' ' version  ': processing "' Animal '" frame # ' num2str(startFrame) ' (' num2str(1) '/' num2str(nFrames) '): INITIALIZATION']);
disp('---------------------------------------------------------------------------------');

% Checking Existence of last CPT backup file before running (3.5):
lastBackupFile = [pathCPTbackupFiles '_' num2str(finalFrame, digitsFormat) '.mat'];
lastImageFile = [gridFolderCPT filesep 'Frames' filesep filenameCPT '_' num2str(finalFrame, digitsFormat) '.png']; % 3.15
if exist(lastBackupFile,'file') && ~makeCPTimages % won't rerun if not asking for images (3.15)
    % if exist(lastBackupFile,'file')
    fprintf([program ' WARNING: LAST backup already exists. Skipping CPT execution...\n']);
    close;
    return
    
elseif exist(lastBackupFile,'file') && (makeCPTimages && exist(lastImageFile,'file'))
    % if user asked to plot images whereas last backup AND image exist => skipping execution (3.16)
    fprintf([program ' WARNING: LAST backup and image already exist! Skipping CPT execution...\n']);
    return
end

%% Defines directories %%

% NB: moved here in 3.16
% NB: Grid SUB folder directory "gridFolderCPT" now created in "AIA_parameters" (as of 3.12+):
backupFolder = [gridFolderCPT filesep 'Backups'];
frameFolder = [gridFolderCPT filesep 'Frames'];
% statisticsFolder = [saveFolder filesep 'Statistics']; % 2.10

% Making directories
if ~exist(backupFolder,'dir')
    mkdir(backupFolder)
end
if ~exist(frameFolder,'dir') && makeCPTimages % only creates folder if images will be generated (3.24)
    mkdir(frameFolder)
end

%% Loading CTD backups (3.14, 3.15) %%

load([pathFolderCTD filesep 'allDelaminatingCells.mat']);   % Loading "allDelaminatingCells.mat" (mod 3.14)
[allMacroRNs, allMacroANs] = LoadMacroBackup(pathFolderCTD);      % 3.14

% Loading "allNewJunctions.mat" if new junction display required (3.15, 3.31)
if displayNewT1Junctions || displayNewDivJunctions || displayNewDelJunctions
    
    allNewJunctionsFile = [pathFolderCTD filesep 'allNewJunctions.mat'];
    if exist(allNewJunctionsFile,'file')
        load(allNewJunctionsFile);
        
        if exist('allNewDivCouplesTF','var')
            cnjARG.allNewCoupleANs = allNewCoupleANs;
            cnjARG.allNewFrames = allNewFrames;
            cnjARG.newDivCouplesTF = allNewDivCouplesTF;
            cnjARG.newDelCouplesTF = allNewDelCouplesTF;
            cnjARG.newT1CouplesTF = allNewT1CouplesTF;
            
            cnjARG.newJuncDisplayFrames = newJuncDisplayFrames;
            cnjARG.displayNewT1Junctions = displayNewT1Junctions;
            cnjARG.displayNewDivJunctions = displayNewDivJunctions;
            cnjARG.colorNewT1Junctions = colorNewT1Junctions;
            cnjARG.colorNewDivJunctions = colorNewDivJunctions;
            cnjARG.displayNewDelJunctions = displayNewDelJunctions;
            cnjARG.colorNewDelJunctions = colorNewDelJunctions;
        else
            fprintf('ERROR: lists of new junctions origin "allNewDivCouplesTF", "allNewDelCouplesTF", "allNewT1CouplesTF"\n')
            fprintf('are not listed in the "allNewJunctions.mat" backup! This is probably due to CTD backups generated by\n')
            fprintf('a version of CTD older than v3.31. Please rerun CTD OR set all junction displays to OFF in SAP_parameters.\n')
            return
        end
    else
        disp('ERROR: CTD backup "allNewJunctions.mat" backup does not exist! Please rerun CTD after having generated SIA backups.')
        return
    end
end

%% ITERATION OVER FRAMES: tracking of defined cell patches %%

progressbar(['CPT iteration over ' Animal ' frames...'])

for n = startFrame:finalFrame
    
    %% Displaying info (mod 3.4, 3.16) %%
    
    index = n - startFrame + 1;                                                     % 3.14
    time = frame2time(n, timeRef, frameRef, dt,'str');                              % determines time (2.2), 2.11
    backupFile = [pathCPTbackupFiles '_' num2str(n, digitsFormat) '.mat'];          % 3.16
    nextBackupFile = [pathCPTbackupFiles '_' num2str(n+1, digitsFormat) '.mat'];	% 3.19
    
    if n > startFrame
        
        disp(' '); disp(' ');
        disp([program ' ' version  ': processing "' Animal '" frame # ' num2str(n) ' (' num2str(index) '/' num2str(nFrames) ')']);
        disp('---------------------------------------------------------------------------------');
    end
    
    %% Loading txt files from C++ tracking AND segmented image (mod 3.14, 3.16) %%
    
    fprintf('Loading tracking txt files and segmented image...');
    
    CorrespondenceRaw = dlmread([trackingFolder filesep 'correspondence_' num2str(n) '.txt']); % 2.10
    Correspondence = FormatCorrespondence(CorrespondenceRaw, nColTotal);                       % 3.9
    clear CorrespondenceRaw;
    % NB: all "Correspondence" arrays should therefore have the same number of columns
    
    coalescedRNs = dlmread([trackingFolder filesep 'coalesced_cells_RN_' num2str(n) '.txt']);
    coalescedRNs = coalescedRNs(coalescedRNs > 0);                                                         % removes -1 stored when empty txt file
    
    newRNs = dlmread([trackingFolder filesep 'new_cells_RN_' num2str(n) '.txt']);
    newRNs = newRNs(newRNs > 0);
    
    % Loading RNs that will delaminatinate between n & n+1 from CTD backups (3.14)
    apoptoticLastRNsTF = allLastFramesDel == n;
    apoptoticLastRNs = allDelaminatingLastRNs(apoptoticLastRNsTF);
    
    % loading segmented image (moved up 3.16)
    segImage = imread([pathFolder filesep filename num2str(n, digitsFormat) '.' imageFormat]);
    segImageLabels = GetImageLabels(segImage);    % REcreates the image labelled uint8 or uint16 according to the number of regions (2.15), use of GetImageLabels (3.13)
    
    % Path to this SIA backup (moved up 3.16)
    pathSIAbackupFileRoot = [pathFolderSIA filesep 'Backups' filesep filenameSIA '_']; % mod 3.10
    pathSIAbackupFile = [pathSIAbackupFileRoot num2str(n, digitsFormat),'.mat'];
    
    fprintf('Done\n');
    
    %% Retrieving this frame macrochaetaes RNs (overhaul 3.14, moved 3.16)%%
    
    macroRNs = [];                      % default (3.18)
    if ~isempty(allMacroANs)
        macroRNs = allMacroRNs(:,n);    % 3.14
    end
    
    %% Defining "ancestorAllDelANs" for Delamination display (3.32)%%
    
    %%% Making delaminating ANs ancestor 3D matrix "ancestorAllDelANs"
    if showApoptoses
        if n == startFrame
            fprintf('Building "ancestorAllDelANs" 3D matrix to generate CTD images...')
            nDelANs = length(allLastFramesDel);
            ancestorAllDelANs = NaN(nColTotal-1, nDelANs, maxDivisionRound+1);
            ancestorAllDelANs(:,:,1) = allDelaminatingANs'; % initialized with actual delaminating ANs
            for d = 2:maxDivisionRound+1
                ancestorAllDelANs(:,:,d) = MakeMothers(ancestorAllDelANs(:,:,d-1)')'; % taking mothers at each rounds
            end
            fprintf('Done.\n')
        end
    end
    
    %% FULL RUN VS EXISTING BACKUP (3.16)%%
    
    %%% Defining filename of CPT image (3.19)
    CPTimageFilenameShort = [filenameCPT '_'  num2str(n,digitsFormat) '.' imageFormatOutput]; % 2.10, moved up 3.19
    CPTimageFilename = [frameFolder filesep CPTimageFilenameShort];                         % 3.19
    
    if ~exist(backupFile,'file') % 3.16
        
        %% Loading SIA backup to determine cell centroids, indices, cellRNs, FLRNs, coreRNs in CURRENT frame # n %%
        
        % Loads SIA backups and extract required quantities (2.2, 3.8):
        fprintf('Loading SIA backup file...');

        load(pathSIAbackupFile,'CELLS'); % simplified 3.11
        
        cellRNs = CELLS.Numbers;
        nCells = length(cellRNs);
        cellXYs = CELLS.XYs;
        cellCategoryTags = CELLS.CategoryTags;                              % 3.22
        [coreRNs, FLRNs, borderRNs] = GetCellCategories(cellCategoryTags); % 3.22
        nonCoreRNs = setdiff(cellRNs, coreRNs);         % 3.9
        cellNeighbors = CELLS.Neighbors;
        cellNneighbors = CELLS.nNeighbors;             % 2.14
        cellContourIndices = CELLS.ContourIndices;     % 2.3
        
        % Additional quantities for EGrids (3.5)
        if strcmp(gridType,'E')
            cellAreas = CELLS.Areas;
            nonCoreCells = sort([borderRNs ; FLRNs]);
            boxArea = xywh(3)*xywh(4);
        end
        
        cellBNs = NaN(nCells,1);                  % cell box numbers (BNs,linear index of box)
        
        fprintf('Done\n')
        
        %% DETERMINATION (starFrame) AND TRACKING OF CELL PATCHES %%
        
        if n == startFrame
            
            %% Loading image AND SIA backup for "gridFrame" (2.13, 3.3, 3.5) %%
                        
            % CASE 1: Loading image and SIA backup corresponding to gridTime
            if gridFrame ~= startFrame && strcmp(gridType,'L')      % otherwise, nothing to do because already done for starFrame
                                
                gridImage = imread([pathFolder filesep filename num2str(gridFrame, digitsFormat) '.' imageFormat]); % Loads segmented image for grid plot
                gridImageCC = bwconncomp(gridImage,4);
                gridImageLabels = labelmatrix(gridImageCC); % REcreates the image labelled uint8 or uint16 according to the number of regions (2.15)
                
                %%% Loads SIA backups and extract required quantities (2.2):
                disp('Loading SIA backup file for "gridFrame"...');
                gridFrameBU = load([pathSIAbackupFileRoot num2str(gridFrame, digitsFormat),'.mat'],'CELLS'); % 3.8, 3.11
                
                gridFrameCellRNs = gridFrameBU.CELLS.Numbers;
                gridFrameCellXYs = gridFrameBU.CELLS.XYs;
                gridFrameNeighbors = gridFrameBU.CELLS.Neighbors ;    % 3.27
                gridFrameCellCategoryTags = gridFrameBU.CELLS.CategoryTags ;    % 3.22
                gridFrameCoreRNs = GetCellCategories(gridFrameCellCategoryTags); % 3.22
                gridFrameNonCoreRNs = setdiff(gridFrameCellRNs, gridFrameCoreRNs); % 3.9
                
                gridFrameCellContourIndices = gridFrameBU.CELLS.ContourIndices ;    % 3.28
                
                %%% Loading txt files from C++ tracking (common to TA and CppT_display)
                gridFrameCorrespondenceRaw = dlmread([trackingFolder filesep 'correspondence_' num2str(gridFrame) '.txt']);
                % Expanding nb Correspondence columns according to "max_n_divisions_nStart-nEnd.txt":
                gridFrameCorrespondence = FormatCorrespondence(gridFrameCorrespondenceRaw, nColTotal);                            % 3.9
                clear gridFrameCorrespondenceRaw;
                % NB: all "Correspondence" arrays should therefore have the same number of columns
                
            else % CASE 2: gridFrame ~= startFrame OR E grid: in this case, everything has been already loaded
                                
                gridImage = segImage;
                gridImageLabels = segImageLabels;
                
                gridFrameCellRNs = cellRNs;
                gridFrameCellXYs = cellXYs;
                gridFrameNeighbors = cellNeighbors; % 3.27
                gridFrameCoreRNs = coreRNs;
                gridFrameCorrespondence = Correspondence;
                gridFrameNonCoreRNs = nonCoreRNs; % 3.9
                
                gridFrameCellContourIndices = cellContourIndices; % 3.28
            end
                      
            %% Excluding cells NOT trackable throughout movie (3.9, 3.10) %%
            
            % NB: will gather coreRootANs in LAST image of movie with all delaminatiedRootANs and check which can be found
            % among coreANs/RNs in START frame. Then ONLY keep those
            
            cells2BeExcludedFromGridFrameRNs = []; % default
            
            % 1ST LEVEL OF FILTERING: initially keeping a cell that will lose some daughters
            if excludeLostCells > 0 && gridType == 'L'          % ONLY L grid (3.24)
                
                fprintf('Determining cells trackable throughout the whole movie...');
                
                % Loading finalFrame correspondence file:
                finalCorrespondenceRaw = dlmread([trackingFolder filesep 'correspondence_' num2str(finalFrame) '.txt']);    % 2.10
                finalCorrespondence = FormatCorrespondence(finalCorrespondenceRaw, nColTotal);                            % 3.9
                clear CorrespondenceRaw;
                
                % loading finalFrame SIA backup file:
                finalFrameBU = load([pathSIAbackupFileRoot num2str(finalFrame, digitsFormat),'.mat'],'CELLS'); % 3.8
                finalFrameCellCategoryTags = finalFrameBU.CELLS.CategoryTags;       % 3.22
                finalFrameCoreRNs = GetCellCategories(finalFrameCellCategoryTags); 	% 3.22
                
                % list of ANs found in last frame
                finalFrameCoreANs = RNs2ANs(finalFrameCoreRNs, finalCorrespondence);
                finalFrameCoreRootANs = unique(finalFrameCoreANs(:,1));
                
                % All core root ANs found in LAST frame to look for in START frame
                allFinalRootANs = unique([finalFrameCoreRootANs ; delaminatingRootANs]); % adding delaminated ANs to list
                
                % 2ND LEVEL OF FILTERING: exclude cells with 1+ lost daughter cells
                if excludeLostCells > 1
                    
                    % Removing all ANs that had 1+ daughter lost (3.10)
                    % ---------------------------------------------------------------------------------------------------
                    % List of all last ANs of divided cells
                    % loading CTD backup "allDividingCells.mat"
                    load([pathFolderCTD filesep 'allDividingCells.mat'],'allDividingANs');
                    
                    % from list of divided cells, get list of cells that ever existed in the tissue
                    [allDaughter1ANsThatExisted, allDaughter2ANsThatExisted] = MakeDaughters(allDividingANs); % 3.14
                    allDaughterANsThatExisted = [allDaughter1ANsThatExisted ; allDaughter2ANsThatExisted]; % 3.14
                    % remove those that can still be found in divided list (because means they re-divided)
                    allExistingDaughterANsCandidates = setdiff(allDaughterANsThatExisted, allDividingANs, 'rows');
                    % remove those that delaminated
                    allExistingDaughterANsCandidates = setdiff(allExistingDaughterANsCandidates, allDelaminatingANs, 'rows');
                    % compare what remains to ANs remaining in the tissue: those NOT there got lost => their
                    % rootANs should be added to the list of cells to exclude
                    lostDaughterANs = setdiff(allExistingDaughterANsCandidates, finalFrameCoreANs, 'rows');
                    lostDaughterRootANs = unique(lostDaughterANs(:,1));
                    
                    allFinalRootANs = setdiff(allFinalRootANs, lostDaughterRootANs);
                    % NB: some bulk cells can fuse and be lost other than by delamination or by going out of field
                    % ---------------------------------------------------------------------------------------------------
                end
                
                % Looking for those found among coreRNs of START frame
                startCoreRNsfoundInFinalRootANsTF = ismember(coreRNs, allFinalRootANs);
                startCoreRnANsUNfoundInFinalRootANs = coreRNs(~startCoreRNsfoundInFinalRootANsTF); % unfound RNs/ANs among core RNs in first frame
                
                % Determining corresponding RNs IN **GRID** FRAME to add to "gridFrameBorderRNs" and remove from "gridFrameCoreRNs"
                cells2BeExcludedFromGridFrameANsTF = ismember(gridFrameCorrespondence(:,2),startCoreRnANsUNfoundInFinalRootANs);
                cells2BeExcludedFromGridFrameANs = gridFrameCorrespondence(cells2BeExcludedFromGridFrameANsTF,2:end);
                
                cells2BeExcludedFromGridFrameRNs = ANs2RNs(cells2BeExcludedFromGridFrameANs, gridFrameCorrespondence);
            end
            
            % Updating "gridFrameNonCoreRNs" and "gridFrameCoreRNs":
            gridFrameNonCoreRNs = unique([gridFrameNonCoreRNs; cells2BeExcludedFromGridFrameRNs]);  % extending list of border RNs to cells NOT found throughout the tracking
            % removing from "gridFrameCoreRNs"
            gridFrameCoreRNs = setdiff(gridFrameCoreRNs, cells2BeExcludedFromGridFrameRNs);
            
            fprintf('Done\n');
                       
            %% IF cloneTracking, determination of clone WT counterparts (3.3, 3.9, 3.28) %%
            
            if cloneTracking
                
                [cloneImageLabelsFiltered, wtImageLabelsFiltered] = FilterCloneImageLabels(cloneImageLabels, yMid, gridFrameNonCoreRNs, gridFrameCellContourIndices, gridImageLabels, matchingWTclone, nCellsMin); % 3.3, using "gridFrameNonCoreRNs" in 3.9
                % NB: IF "matchingWTclone"= true AND yMid NOT empty, filtering out clone pixels without WT counterpart on other side of midline
                % (either because out-of-bounds OR because other clone region)
                % NB: many pixel can be killed in "cloneImageLabelsFiltered", but "ny" and region numbering is conserved from SAP.
                
            end
                        
            %% Saving txt file indicating date, version and parameters used in "saveFolder" (2.13)
            
            today = datestr(now,29);                      % format 29 displays date yyyy-mm-dd style. Look up date for details
            txtFilename = [today '_CPT_' version '.txt'];
            % Writing main parameters in txt file:
            parameterCell = {   'Relevant common Parameters:',[];
                [],[];
                'excludeLostCells = ', excludeLostCells;    % 3.10
                'nCellsMin = ', nCellsMin;              % 3.28
                'PIVgrid = ', PIVgrid;                  % 3.5
                'cloneTracking = ', cloneTracking;      % 3.5
                'gridType = ', gridType;                % 3.5
                'gridTime = ', gridTime;
                'gridOverlap =', gridOverlap;           % 3.5
                'nLayers =', nLayers;                   % 3.5
                'displayCellNumbers = ', displayCellNumbers;
                [],[];
                'CPT Parameters:',[];
                [],[];
                'matchingWTclone = ', matchingWTclone;      % 3.7
                'includeNewCells = ', includeNewCells;      % 3.12
                'makeCPTimages =', makeCPTimages;           % 3.5
                'keepPatchColors =', keepPatchColors;       % 3.5
                'midlineSymmetry = ', midlineSymmetry;
                'showNewCells = ', showNewCells;
                'showCoalescedCells = ', showCoalescedCells;
                'showApoptoses = ', showApoptoses}; % 3.7
            
            dlmcell([gridFolderCPT filesep txtFilename], parameterCell,' '); % using "saveFolder" instead of "pathFolderCPT" (3.5)
                       
            %% Assigns colors of grid compartments (mod 2.12, 3.5, 3.15)%%
            
            % NB: Defines random colors for each box (checking it's far enough already assigned colors):
            
            gridDefBU = load(pathGridDefFile); % 3.24
            
            if  (~isfield(gridDefBU,'PatchColors') || ~keepPatchColors) || ~isempty(singlePatchColor)  && ~cloneTracking % 3.5, 3.6, 3.15, 3.23
                
                fprintf('Assigning NEW colors to each grid compartment...')
                
                gridPatchColors = cell(ny,nx);
                
                deltaLim = 0.1*sqrt(3);                     % minimal distance (norm) of cell color patches to already assigned colors (2.5)
                colorFading = 0.5;
                refColors = [black ; colorFLCells ; colorNewCells ; colorApoptosis ; colorFusion]; % 2.5
                
                for b = 1:nBoxes
                    
                    [ky,kx] = ind2sub([ny nx],b);                           % turns linear index b into (i,j) grid coordinate (2.12)
                    
                    if isempty(singlePatchColor) % 3.15
                        
                        boxColor = rand(1,3);
                        boxColor = FadeColor(boxColor,colorFading); % 2.12
                        neighborColors = [ gridPatchColors{max(1,ky-1),kx};
                            gridPatchColors{min(ny,ky+1),kx};
                            gridPatchColors{ky,min(nx,kx+1)};
                            gridPatchColors{ky,max(1,kx-1)};
                            ];
                        
                        forbiddenColors = [neighborColors ; refColors];
                        nFC = size(forbiddenColors,1);
                        deltaColors = forbiddenColors - repmat(boxColor,nFC,1);
                        normDeltaColors = sqrt(sum(deltaColors.^2,2));
                        
                        while min(normDeltaColors) < deltaLim % added min (2.5)
                            boxColor = rand(1,3);
                            boxColor = FadeColor(boxColor,colorFading); % 2.12
                            deltaColors = forbiddenColors - repmat(boxColor,nFC,1);
                            normDeltaColors = sqrt(sum(deltaColors.^2,2));  
                        end
                    else
                        boxColor = singlePatchColor; % applies unique color (3.15)
                    end
                    gridPatchColors{ky,kx} = boxColor;               % assigns this color that passed the above tests, fade to white (2.5)
                end
                
                % Redefining half of colors if symmetry was chosen (2.2):
                if midlineSymmetry && ~cloneTracking
                    for kx = 1:nx
                        if floor(ny/2) == ny/2  % ny is EVEN
                            for ky = 1:ny/2
                                gridPatchColors{ny+1-ky,kx} = gridPatchColors{ky,kx}; % added +1 (2.3)
                            end
                        else                     % ny is ODD
                            for ky = 1:(ny-1)/2
                                gridPatchColors{ny+1-ky,kx} = gridPatchColors{ky,kx};
                            end
                        end
                    end
                end
                
            elseif ~cloneTracking  % grid Def backup exists => loading existing colors (3.5) unless its cloneTracking (3.6)
                
                fprintf('Loading colors ALREADY assigned to each grid compartment from "GridDef backup"...')
                
%                 gridDefBU = load(pathGridDefFile);
                gridPatchColors = gridDefBU.PatchColors;
                clear gridDefBU;  
            end
            
            % ONLY separating clone VS WT matching parts (3.2, 3.6)
            if cloneTracking
                if nx ==1
                    fprintf('Assigning colors to clone...')
                elseif nx == 2
                    fprintf('Assigning colors to clone AND WT matching parts...')
                end
                gridPatchColors = cell(ny,nx);
                patchColors = [colorClone ; colorWT]; % 3.6
                for kx = 1:nx
                    for ky = 1:ny
                        gridPatchColors{ky,kx} = patchColors(kx,:); % kx = 1 => clone color, kx = 2 => WT color (3.6)
                        % gridPatchColors{ky,kx} = gridPatchColors{1,kx}; % repeats first row color in each column
                    end
                end
            end
            
            fprintf('Done\n')
                       
            %% Initialization of arrays %%
            
            gridCoreRNs = cell(ny,nx);
            gridCoreANs = cell(ny,nx);
            gridContourIndices = cell(ny,nx);   % 3.1
            gridnCoreRNs = zeros(ny,nx);        % 3.1
            
            if strcmp(gridType,'L') % 3.5
                gridCoreBNs = cell(ny,nx);          % 2.14
                gridLcentroids = cell(ny,nx);       % 3.1
            else
                onlyCoreCellsTF = true(ny,nx);
                gridBoxCellArea = zeros(ny,nx);     % 3.5
            end
            
            gridCellBoxYXs = NaN(nCells,2);     % for each cell, will store the box (kx,ky) to which it belongs
                        
            %% Determination of ANs of core cells and FL cells to track %%
            
            fprintf('Determining initial list of cell ANs to track in each grid compartment...')
            
            for b = 1:nBoxes
                
                [ky,kx] = ind2sub([ny nx],b);     % turns linear index b into (i,j) grid coordinate (2.13)
                
                %% Determining cell RNs within each grid compartments box(ky,kx) *** IN "gridFrame" FRAME *** (1st iteration) %%
                
                %%% boxCoreRNs:
                if ~cloneTracking
                    
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    boxRNs = FindBoxRNs(ky, kx, GRID_DEF, gridFrameCellRNs, gridFrameCellXYs, scale1D); % for both E & L grid at this point
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    
                    boxCoreRNs = intersect(boxRNs, gridFrameCoreRNs);                              % removes image borderRNs and FLRNs
                    
                    % Determination of AreaRatios value in this EULERIAN box (3.5)
                    if strcmp(gridType,'E')
                        
                        boxNonCoreRNs = intersect(boxRNs, nonCoreCells);
                        gridBoxCellArea(ky,kx) = sum(cellAreas(boxCoreRNs)); % cumulated area of core cells in E OR L box
                        
                        if isempty(boxCoreRNs) || ~isempty(boxNonCoreRNs) % first checks if box_cell_RNs is empty
                            onlyCoreCellsTF(ky,kx) = false;
                        end
                    end  
                else
                    % CLONE TRACKING CASE
                    if kx == 1
                        % actual clone parts: using "cloneImageLabelsFiltered"
                        boxRNs = FindCloneRNs(ky, cloneImageLabelsFiltered, gridFrameCellXYs, scale1D); % 3.2, removed ky (3.26), put back (3.28)
                    else
                        % matching WT parts: using "cloneImageLabelsFlipped"
                        boxRNs = FindCloneRNs(ky,wtImageLabelsFiltered, gridFrameCellXYs, scale1D); % 3.2, removed ky (3.26), put back (3.28)
                    end
                    boxCoreRNs = intersect(boxRNs, gridFrameCoreRNs);    % removes image borderRNs and FLRNs
                end
                
                %%% Excluding macrochaetaes (3.7)
                boxCoreRNs = setdiff(boxCoreRNs, macroRNs);
                
                % Removing single cells having NO neighbors belonging to their box (3.27)
                boxCoreNeighbors = gridFrameNeighbors(boxCoreRNs); % gets neighbors
                boxCoreRNsNotAloneTF = cellfun(@(x) ismember(x, boxCoreRNs), boxCoreNeighbors,'UniformOutput',false); % checks if neigbhors are in box
                boxCoreRNsNotAloneTF = cellfun(@(x) any(x,2), boxCoreRNsNotAloneTF);        % locates RNs for which 1+ neighbor is part of the box
                boxCoreRNs = boxCoreRNs(boxCoreRNsNotAloneTF);                              % ONLY keeping cells having one neighbor in box
                
                
                %% Getting cell ANs for Core cells %%
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                boxCoreRNsTF = ismember(gridFrameCorrespondence(:,1), boxCoreRNs);
                boxCoreANs = gridFrameCorrespondence(boxCoreRNsTF, 2:end);
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % NB:  THIS IS THE INITIAL LIST OF CORE CELLS ANs TO TRACK IN THIS BOX! (Acells and Ncells will be
                % added later, as well as those cell offspring)
                               
                %% Storage of RNs (mod 2.13)
                
                if gridFrame ~= startFrame && strcmp(gridType,'L') % need to find the corresponding RNs in starFrame
                    
                    % - determine all possible first Mother ANs (with all 0s): those are the one found in startFrame
                    boxCoreAncestorsANs = MakeAncestors(boxCoreANs,'oldest');     % initial mothers are repeated as many times as daughters
                    % NB: PB: daughters belonging to different patches will give conflicts for mothers => assiging
                    % mother to a given patch => daughters WILL BE REASSIGNED to their mother patch
                    
                    % determine RNs corresponding to ANs for "startFrame"
                    boxCoreAncestorsRNs = ANs2RNs(boxCoreAncestorsANs,Correspondence); % NOT using "gridFrameCorrespondence" this time
                    
                    % Removing non core cells (2.14):
                    boxCoreRNsTF = ismember(boxCoreAncestorsRNs,coreRNs);
                    boxCoreAncestorsRNs = boxCoreAncestorsRNs(boxCoreRNsTF);
                    
                    % Removing single cells having NO neighbors belonging to their box (3.27)
                    boxCoreAncestorsNeighbors = cellNeighbors(boxCoreAncestorsRNs); % gets neighbors IN CURRENT FRAME => NOT using "gridFrameNeighbors"
                    boxCoreAncestorsRNsNotAloneTF = cellfun(@(x) ismember(x, boxCoreAncestorsRNs), boxCoreAncestorsNeighbors,'UniformOutput',false); % checks if neigbhors are in box
                    boxCoreAncestorsRNsNotAloneTF = cellfun(@(x) any(x,2), boxCoreAncestorsRNsNotAloneTF);      % locates RNs for which 1+ neighbor is part of the box
                    boxCoreAncestorsRNs = boxCoreAncestorsRNs(boxCoreAncestorsRNsNotAloneTF);                   % ONLY keeping cells having one neighbor in box
                    
                    % redefining "boxCoreAncestorsANVS" according to "boxCoreAncestorsRNs" (2.14)
                    boxCoreAncestorsANs = RNs2ANs(boxCoreAncestorsRNs,Correspondence);
                    
                    % overwrite "boxCoreANs" and "boxCoreRNs" with the one determined for startFrame
                    boxCoreRNs = boxCoreAncestorsRNs;
                    boxCoreANs = boxCoreAncestorsANs;
                    % NB: we are now back to the initial case of version 2.12
                    
                    % filling gridCoreBNs (2.14)
                    nBoxCoreRNs = length(boxCoreRNs);
                    boxCoreBNs = repmat(b, nBoxCoreRNs, 1); % repeats box number to match cell number in box (mod 3.27)
%                     boxCoreBNs = b*ones(nBoxCoreRNs,1); % repeats box number to match cell number in box
                    gridCoreBNs{ky,kx} = boxCoreBNs;         
                else
                    if strcmp(gridType,'L') % 3.5
                        % Determining "Lcentroids" and patch contour (doing it now since gridFrame = startFrame):
                        % Creation of "Lcentroids" (centroids of LBox) in GRID:
                        boxCoreXYs = cellXYs(boxCoreRNs,:);
                        gridLcentroids{ky,kx} = mean(boxCoreXYs,1)/scale1D;     % back in PIXELS, similarly to EGrid case
                    end
                    
                    % Getting this patch contour indices (3.1):
                    boxCellContourIndices = cell2mat(cellContourIndices(boxCoreRNs));
                    otherCellRNs = setdiff(cellRNs, boxCoreRNs);
                    otherCellContourIndices = cell2mat(cellContourIndices(otherCellRNs));
                    boxContourIndices = intersect(boxCellContourIndices, otherCellContourIndices);
                    gridContourIndices{ky,kx} = boxContourIndices;
                    
                    % gridnCoreRNs (3.1):
                    gridnCoreRNs(ky,kx) = length(boxCoreRNs);
                end
                
                %%% Storage (may be updated later):
                gridCoreANs{ky,kx} = boxCoreANs;
                gridCoreRNs{ky,kx} = boxCoreRNs;
                
                %%% Storage of box coordinate to which these Core cells belong:
                nBoxCoreRNs = length(boxCoreRNs);
                gridCellBoxYXs(boxCoreRNs,1) = kx; % 3.1
                gridCellBoxYXs(boxCoreRNs,2) = ky; % 3.1
                
                % fills "cellBNs" for these core cell RNs (2.7)
                cellBNs(boxCoreRNs) = b;                        % store this box linear number at each cell RN
                
                if isempty(boxCoreRNs)
                    disp(['Warning: box (' num2str(ky) ',' num2str(kx) ') contains no cell centroid!'])
                end
                
            end
            fprintf('Done\n')
            
            % making a column vector of all core cell RNs (most RNs are REPEATED at this point if gridFrame ~= startFrame) (mod 3.32)
            gridCoreRNsEmptyTF = cellfun(@isempty, gridCoreRNs);
            gridCoreRNsCrop = gridCoreRNs(~gridCoreRNsEmptyTF);
            gridAllCoreRNs = cell2mat(gridCoreRNsCrop(:)); % 3.32
            % NB: this crop before using "cell2mat" is because one gets a
            % weird bug when concatenating EMPTY compartmeent of different
            % sizes!! (1x0 vs 0x0!!)
            
%             gridAllCoreRNs = cell2mat(reshape(gridCoreRNs,nx*ny,1)); % using cell2mat (2.13)
                      
            %% IF gridFrame ~= startFrame & L grid: Fixing conflicts & Integration of A/D cells to existing patches (2.13,2.14) %%
            
            if gridFrame ~= startFrame && strcmp(gridType,'L') % need to find the corresponding RNs in starFrame
                
                % Fixing conflicts of mother RNs belonging to several boxes (2.14)
                %--------------------------------------------------------------------------------------------
                gridAllCoreBNs = cell2mat(gridCoreBNs(:));
%                 gridAllCoreBNs = cell2mat(reshape(gridCoreBNs,nx*ny,1)); % makes vector of box numbers matching gridAllCoreRNs (where RNs are repeated)
                % NB: cannot use cellBNs where each RNs has (wrongly) been assigned a box already (when using gridFrame)
                
                gridAllCoreRNsUnique = unique(gridAllCoreRNs);
                nCoreRNs = length(gridAllCoreRNsUnique);
                
                for r = 1:nCoreRNs
                    rRN = gridAllCoreRNsUnique(r);
                    rRNtf = ismember(gridAllCoreRNs,rRN);
                    rRNloc = find(rRNtf);
                    rRNboxesRepeat = gridAllCoreBNs(rRNloc);        % get vector of box numbers for this RN
                    rRNboxes = unique(rRNboxesRepeat);
                    
                    if length(rRNboxes) > 1 % several box values were found for this RN
                        
                        boxCount = histc(rRNboxesRepeat,rRNboxes);       % counts occurences for each box number; using "histc" rather than "hist" (3.21)
                        [boxCountMax, boxCountMaxLoc] = max(boxCount);  % get index of box with most count (first occurence when equal count)
                        boxPicked = rRNboxes(boxCountMaxLoc);
                        gridAllCoreBNs(rRNloc) = boxPicked;             % assigning unique box value to all repeated RNs
                    end
                end
                
                % cropping lists to only one occurence
                [~,gridAllCoreRNsLoc] = ismember(gridAllCoreRNsUnique, gridAllCoreRNs); % finds highest index in gridAllCoreRNs for each RN
                gridAllCoreRNs = gridAllCoreRNsUnique;
                
                gridAllCoreBNsUnique = gridAllCoreBNs(gridAllCoreRNsLoc);   % retrieves box number for each
                gridAllCoreBNs = gridAllCoreBNsUnique;                      % vector matching gridAllCoreRNs
                
                cellBNs(gridAllCoreRNs) = gridAllCoreBNs;                  % updating cellBNs
                %--------------------------------------------------------------------------------------------
                
                
                % REassigning isolated cells detached from patch to patch with which it shares the most neigbhors (in startFrame) (2.14)
                %--------------------------------------------------------------------------------------------
                nCoreNeighbors = cellNneighbors(gridAllCoreRNs);
                nCoreNeighborsMax = max(nCoreNeighbors);
                coreNeighborRNs = NaN(nCoreRNs, nCoreNeighborsMax);
                coreNeighborBNs = NaN(nCoreRNs, nCoreNeighborsMax);
                
                for r = 1:nCoreRNs
                    
                    rRN = gridAllCoreRNsUnique(r);
                    rNneighbors = cellNneighbors(rRN);
                    rNeighbors = cellNeighbors{rRN};
                    coreNeighborRNs(r,1:rNneighbors) = rNeighbors;
                    
                    rNeighborBNsTF = ismember(gridAllCoreRNs, rNeighbors);
                    nNeighborBoxes = sum(rNeighborBNsTF);
                    rNeighborsBNs = gridAllCoreBNs(rNeighborBNsTF); % retrieves only boxes of gridAllCoreRNs (not all core_cells)
                    coreNeighborBNs(r,1:nNeighborBoxes) = rNeighborsBNs;
                    % NB: location of boxes in columns DO NOT match position of neighbors anymore, BUT position of rows
                    % still correspond to gridAllCoreRNs
                end
                
                deltaCoreNeighborBNs = abs(coreNeighborBNs - repmat(gridAllCoreBNs,1,nCoreNeighborsMax));
                isolatedRNsTF = ismember(deltaCoreNeighborBNs,0);
                isolatedRNsTF = ~any(isolatedRNsTF,2); % 1 on rows where core cells do NOT have any neighbor belonging to their box (detached cells in startFrame)
                isolatedRNsLoc = find(isolatedRNsTF);
                
                if ~isempty(isolatedRNsLoc)
                    fprintf('Reassigning mother RNs detached from patch...')
                    
                    for ind = isolatedRNsLoc' % ind = index of isolated RNs in "gridAllCoreRNs"
                        
                        iNeighborBNs = coreNeighborBNs(ind,:);
                        iNeighborBNsUnique = unique(iNeighborBNs);
                        iNeighborBNsUnique = RemoveNaNs(iNeighborBNsUnique);      % removing NaNs not supported by histc anymore (3.21)
                        
                        if ~isempty(iNeighborBNsUnique) % 3.21
                            
                            nEachBox = histc(iNeighborBNs,iNeighborBNsUnique);  % using "histc" rather than "hist" (3.21)
                            [nBoxMax, nBoxMaxLoc] = max(nEachBox);
                            boxPicked = iNeighborBNsUnique(nBoxMaxLoc);
                            gridAllCoreBNs(ind) = boxPicked; % update box for this RN
                        end
                    end
                    % update cellBNs
                    cellBNs(gridAllCoreRNs) = gridAllCoreBNs;                  % updating cellBNs
                    fprintf('Done\n')
                end
                %--------------------------------------------------------------------------------------------
                
                
                %--------------------------------------------------------------------------------------------
                % load list of A/D cells
                CTDBU = load([pathFolderCTD filesep 'allDelaminatingCells.mat']);
                allDelaminatingANs = CTDBU.allDelaminatingANs;
                allLastFramesDel = CTDBU.allLastFramesDel;
                
                % select those that occurred up to gridFrame
                beforeGridFrameTF = allLastFramesDel < gridFrame;
                delaminatingANs = allDelaminatingANs(beforeGridFrameTF,:);
                
                % get their initial mother ANs
                delaminatingAncestorANs = MakeAncestors(delaminatingANs,'oldest');
                delaminatingAncestorANs = unique(delaminatingAncestorANs,'rows');  % only keep one occurence
                % NB: some of these ANs can already be listed in non-delaminating ANs as some delaminting daughters will
                % cause their initial mother to appear
                
                % get their RNs IN *startFrame* and NOT gridFrame
                delaminatingAncestorRNs = ANs2RNs(delaminatingAncestorANs, Correspondence);
                
                % determining delaminating RNs IN startFrame NOT already listed in "Grid_all_core_cell_RNs"
                missingDelaminatingAncestorRNs = setdiff(delaminatingAncestorRNs, gridAllCoreRNs);
                % NB: indeed, some of "delaminatingAncestorRNs" are not missing and can be found in
                % "Grid_all_core_cell_RNs". They are due to single A/D daughter making their first mother
                % appear in the list. We DON'T want to reassign them.
                
                % removes Border and FL cells of FIRST image
                missingDelaminatingAncestorRNs = intersect(missingDelaminatingAncestorRNs, coreRNs);
                
                % Assigning those RNs to existing patches with "AssignPatch":
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                missingDelaminatingAncestorBNs = AssignPatch(missingDelaminatingAncestorRNs, coreRNs, coalescedRNs, cellNeighbors, cellBNs);
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %--------------------------------------------------------------------------------------------
                
                for b = 1:nBoxes
                    [ky,kx] = ind2sub([ny nx],b);
                    
                    % Assigning mother RNs to box with highest number of daughters (2.14)
                    gridAllCoreBNsTF = ismember(gridAllCoreBNs, b); % fiding RNs assigned to this box
                    boxCoreRNs = gridAllCoreRNs(gridAllCoreBNsTF);  % this box RNs
                    boxCoreANs = RNs2ANs(boxCoreRNs,Correspondence);
                    
                    % finding A/D RNs assigned to box b:
                    bMissingRNsTF = missingDelaminatingAncestorBNs == b;
                    bMissingRNs = missingDelaminatingAncestorRNs(bMissingRNsTF);
                    bMissingANs = RNs2ANs(bMissingRNs, Correspondence);
                    
                    % adding rescued A/D cells:
                    boxCoreRNs = [boxCoreRNs; bMissingRNs];           %#ok<AGROW>
                    boxCoreANs = [boxCoreANs; bMissingANs];         %#ok<AGROW>
                    
                    % Updates:
                    gridCoreANs{ky,kx} = boxCoreANs;
                    gridCoreRNs{ky,kx} = boxCoreRNs;
                    
                    % filling gridCoreBNs (2.14)
                    nBoxCoreRNs = length(boxCoreRNs);
                    boxCoreBNs = b*ones(nBoxCoreRNs,1); % repeats box number to match cell number in box
                    gridCoreBNs{ky,kx} = boxCoreBNs;
                    
                    
                    % Determining "Lcentroids" and patch contour (ONLY doing it now since gridFrame ~= startFrame):
                    % Creation of "Lcentroids" (centroids of LBox) in GRID:
                    boxCoreXYs = cellXYs(boxCoreRNs,:);
                    gridLcentroids{ky,kx} = mean(boxCoreXYs,1)/scale1D;     % back in PIXELS, similarly to EGrid case
                    
                    % Getting this patch contour indices (3.1):
                    boxCellContourIndices = cell2mat(cellContourIndices(boxCoreRNs));
                    otherCellRNs = setdiff(cellRNs, boxCoreRNs);
                    otherCellContourIndices = cell2mat(cellContourIndices(otherCellRNs));
                    boxContourIndices = intersect(boxCellContourIndices, otherCellContourIndices);
                    gridContourIndices{ky,kx} = boxContourIndices;
                    
                    % gridnCoreRNs (3.1):
                    gridnCoreRNs(ky,kx) = length(boxCoreRNs); % directly puts number of core cells, will be renormalized later
                end
                
                % Updates
                gridAllCoreRNs = cell2mat(reshape(gridCoreRNs,nx*ny,1));
                gridAllCoreBNs = cell2mat(reshape(gridCoreBNs,nx*ny,1));
                cellBNs(gridAllCoreRNs) = gridAllCoreBNs;
            end
            
            % Only keep numbers once and remove 0:
            gridAllCoreRNs = unique(gridAllCoreRNs);
            gridAllFLRNs = setdiff(cellRNs, [gridAllCoreRNs ; borderRNs]);
            gridAllNonBorderRNs = [gridAllCoreRNs ; gridAllFLRNs];
            gridAllBorderRNs = setdiff(cellRNs, gridAllNonBorderRNs);
            % NB: FL cells are ALL cells except Grid core cells AND INITIAL image border cells. Then, those cells are
            % tracked over time and gridAllNonBorderRNs becomes larger than borderRNs.
            
            %%% Getting ANs of FL cells to track:
            gridFLRNsTF = ismember(Correspondence(:,1), gridAllFLRNs);      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            gridFLANs = Correspondence(gridFLRNsTF,2:end);                  % THIS IS THE (CURRENT) LIST OF FL CELLS ANs TO TRACK!
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        
            %% Storage of Constant grid quantities in GRID_DEF %%
            
            %%% Saving 'Grid_color','Grid_cell_box_xy' and lists of ANVS of all possible Core and FL cells to track in each box compartment (patch)  (1.2b, 1.2c):
            GRID_DEF.PatchColors = gridPatchColors;
            
            nCells0 = GetnCells0(trackingFolder, startFrame); % 3.20
            GRID_DEF.nCells0 = nCells0;                       % saves nCells0 value for resume mode (2.0.1), mod 3.20
            
            %%% Saving corresponding backup file:
            save(pathGridDefFile,'-struct','GRID_DEF','-append'); % 3.0, saving in grid parent folder (3.5)
%             save(pathGridDefFile,'-struct','GRID_DEF'); % 3.0, saving in grid parent folder (3.5)

                       
        else % CASE: n > startFrame
            
            %% Re-initialization of arrays %%
            
            gridCoreRNs = cell(ny,nx);
            gridCellBoxYXs = NaN(nCells,2);     % for each cell, will store the box (kx,ky) to which it belongs
            gridAllCoreRNs = [];
            gridAllCoreThatBecameFLRNs = [];
            
            if strcmp(gridType,'E')
                gridCoreANs = cell(ny,nx);      % ANs are reinitialized at each frame
                gridBoxCellArea = zeros(ny,nx);
                onlyCoreCellsTF = true(ny,nx);
            end
            
            %% Determination of this frame cell RNs corresponding to cells ANVS to track %%
            
            if strcmp(gridType,'L') % 3.5
                        
                if ~cloneTracking || (cloneTracking && includeNewCells) % ONLY does new cells integration in that case (3.12)
                    
                    % assigning new CORE cells to specific Grid compartments (Box Number) based on number of neighbors
                    % belonging to these boxes IN PREVIOUS FRAME (2.7)
                    %-------------------------------------------------------------------------------------------------------
                    fprintf('Assigning new core cells to Lagrangian grid compartements...');
                    newCoreRNs = intersect(coreRNs, newRNs);                          % only considering new CORE cells (1.3.5)
                    % NB: therefore, these cells don't have any border cell as neighbors
                    if ~isempty(newCoreRNs)
                        newCoreANs = RNs2ANs(newCoreRNs, Correspondence);          % gets new cells ANs (1.3.3)
                        nNew = length(newCoreRNs);
                        for c = 1:nNew
                            cNeighborRNs = cellNeighbors{newCoreRNs(c)};                                    % gets current neighbors of cth new cell
                            cNeighborRNs = setdiff(cNeighborRNs, [newRNs; coalescedRNs]);                   % excludes neighbors being new cells: box assignment based on neighbors already belonging to a specific box (1.3.5)
                            % NB: excluding neighbor RNs being new cells prevents cases where many layers of cells appear at once
                            % NB: excluding neighbor RNs being coalesced limits errors AND weird box assignement
                            cNeighborANs = RNs2ANs(cNeighborRNs, Correspondence);                            % gets current neighbors ANs (1.3.3)
                            cNeighborANsExt = [cNeighborANs; MakeMothers(cNeighborANs)];                     % neighbor ANs extended to mothers
                            cNeighborRNsOld = unique(ANs2RNs(cNeighborANsExt, CorrespondenceOld));           % gets their RNs in previous frame (1.3.3)
                            cNeighborRNsOld  = setdiff(cNeighborRNsOld , [newRNsOld; coalescedRNsOld]);      % excluding cells that were new and coalesced in previous frame (3.25)
                            
                            cNeighborBNs = cellBNsOld(cNeighborRNsOld);    % list box numbers (repeated) to which c neighbors belonged in previous frame
                            cPossibleBNs = unique(cNeighborBNs);           % all possible Box Numbers for c
                            cPossibleBNs = RemoveNaNs(cPossibleBNs);       % removes NaNs ealier as "histc" does NOT support (3.19)  
                            
                            if ~isempty(cPossibleBNs) % checks that there is 1+ neighbor belonging to a grid box (otherwise all NaNs) (3.19)
                                
                                cPossibleBNsCount = histc(cNeighborBNs,cPossibleBNs);  % returns the number of occurences of each BN listed in "cPossibleBNs"
                                [cBNmax,cBNind] = max(cPossibleBNsCount);                   % if equality in the count, returns the first index
                                cBN = cPossibleBNs(cBNind);                            % found to which box this new cell will be assigned
                                
                                if cBNmax >= 3 % checks that 3+ neighbors belong to the selected grid box (3.25)
                                    % Update of this box ANs:
                                    boxANs = gridCoreANs{cBN};                                            % extracts current box ANs for update
                                    boxANs = [boxANs ; newCoreANs(c,:) ; MakeOffspring(newCoreANs(c,:))]; %#ok<AGROW> adding this cell and offspring
                                    gridCoreANs{cBN} = boxANs;
                                end
                            end
                        end
                    end
                    fprintf('Done\n');
                end
                %-------------------------------------------------------------------------------------------------------
                
                fprintf('Tracking cells in each grid compartments...');
                for b = 1:nBoxes
                    [ky,kx] = ind2sub([ny nx],b);     % turns linear index b into (i,j) grid coordinate (2.13)
                    
                    %%% Tracking ANs of Core cells in this box:
                    boxPossibleCoreANs = gridCoreANs{ky,kx};                                                          % gets this box possible core cells
                    [boxPossibleCoreANsDaughters1, boxPossibleCoreANsDaughters2] = MakeDaughters(boxPossibleCoreANs); % creates daughters (mod 3.14)
                    boxPossibleCoreANsDaughters = [boxPossibleCoreANsDaughters1 ; boxPossibleCoreANsDaughters2];      % 3.14
                    boxPossibleCoreANs = unique([boxPossibleCoreANs ; boxPossibleCoreANsDaughters],'rows');             % only keeping one occurence
                    
                    boxPossibleCoreANsTF = ismember(Correspondence(:,2:end), boxPossibleCoreANs,'rows');      % look for these ANs in Correspondence
                    boxCoreRNs = unique(Correspondence(boxPossibleCoreANsTF,1));                              % gets corresponding RNs in this frame
                    %             boxCoreRNs = ANs2RNs(boxPossibleCoreANs, Correspondence);                 % gets corresponding RNs in this frame (tested in 3.5)
                    boxCoreThatBecameFLRNs = intersect(boxCoreRNs, FLRNs);           % 1.1
                    boxCoreRNs = intersect(boxCoreRNs, coreRNs);                      % crops to actual core cells in image
                    
                    % Looking in current box for coalesced RNs that have already been assigned to another Box and removing them from current box (3.1)
                    %-----------------------------------------------------------------------------------------------------------------------------------
                    %             boxCoreRNs = setdiff(boxCoreRNs, assigned_CRNs);            % removes coalesced regions already assigned to another box
                    %             boxCoalescedRNs = intersect(boxCoreRNs, coalescedRNs);      % coalesced regions in this box, not yet listed in "assigned_CRNs"
                    %             if ~isempty(boxCoalescedRNs)
                    %                 loc_TF = ismember(coalescedRNs, boxCoalescedRNs);       % gets their loc in Coalesced_cells
                    %                 assigned_CRNs(loc_TF) = boxCoalescedRNs;                % adds these coalesced cells to "assigned_CRNs" at their location in "Coalesced_cells"
                    %             end
                    %-----------------------------------------------------------------------------------------------------------------------------------
                    % NB: commented this part because ONLY relevant for NON-overlapping grids. When grids are overlapping, it is
                    % normal to have cells (and coalesced ones) to be listed in multiple times in different grid compartments.
                    
                    % Updates list of core cells to track in each grid compartment:
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% IMPORTANT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    % NB: by using "boxCoreRNs" which ONLY CONTAINS *IMAGE* coreRNs, WE WOULD PERMANENTLY REMOVE ANs THAT
                    % STOPPED BEING CORE AT SOME POINT FROM EACH GRID COMPARTMENT:
                    %             boxCoreANs = RNs2ANs(boxCoreRNs,Correspondence); % tested in 3.5
                    %
                    % BY *NOT* USING IT (3.5-), WE ARE KEEPING THEM IN THE BOX *WHEN* THEY ARE BACK AS CORE CELLS IN IMAGE:
                    boxCoreANs = Correspondence(boxPossibleCoreANsTF,2:end);   % crops to ANs ACTUALLY FOUND (2.1.0)
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% IMPORTANT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    
                    gridCoreANs{ky,kx} = boxCoreANs;                          % Updates list of of ANVS
                    gridCoreRNs{ky,kx} = boxCoreRNs;                             % stores the RNs of this box Core cells we want to keep track of
                    
                    %%% Determines core cells becoming image FL(1.1):
                    gridAllCoreThatBecameFLRNs = [gridAllCoreThatBecameFLRNs ; boxCoreThatBecameFLRNs]; %#ok<AGROW>
                    
                    %%% Storage of box coordinate to which these cells belong (CORE CELLS REALLY??!!! ):
                    gridCellBoxYXs(boxCoreRNs,1) = kx;
                    gridCellBoxYXs(boxCoreRNs,2) = ky;
                    
                    gridAllCoreRNs = [gridAllCoreRNs ; boxCoreRNs]; %#ok<AGROW>
                    
                    % fills "cellBNs" for these cell RNs (2.7)
                    cellBNs(boxCoreRNs) = b;                        % store this box number (=box linear number) at each cell RN
                    
                    % Determining "Lcentroids" (3.1):
                    boxCoreXYs = cellXYs(boxCoreRNs,:);
                    gridLcentroids{ky,kx} = mean(boxCoreXYs,1)/scale1D;     % back in PIXELS, similarly to EGrid case
                    
                    % Getting this patch contour indices (3.1):
                    boxCellContourIndices = cell2mat(cellContourIndices(boxCoreRNs));
                    otherCellRNs = setdiff(cellRNs, boxCoreRNs);
                    otherCellContourIndices = cell2mat(cellContourIndices(otherCellRNs));
                    boxContourIndices = intersect(boxCellContourIndices, otherCellContourIndices);
                    gridContourIndices{ky,kx} = boxContourIndices;
                    
                    % gridnCoreRNs (3.1):
                    gridnCoreRNs(ky,kx) = length(boxCoreRNs); % directly puts number of core cells, will be renormalized later
                end
                fprintf('Done\n');
                
                %%% FL cells:
                possibleGridFLANs = gridFLANs;
                [possibleGridFLANsDaughters1, possibleGridFLANsDaughters2] = MakeDaughters(possibleGridFLANs);  % mod 3.14
                possibleGridFLANsDaughters = [possibleGridFLANsDaughters1 ; possibleGridFLANsDaughters2];       % 3.14
                possibleGridFLANs = unique([possibleGridFLANs ; possibleGridFLANsDaughters],'rows');
                
                % determining actual FL cell in image:
                gridAllFLRNs = ANs2RNs(possibleGridFLANs,Correspondence);            % using "ANs2RNs" (3.5)
                gridAllFLRNs = unique([gridAllFLRNs ; gridAllCoreThatBecameFLRNs]);    % adds list of Core becoming FL in image (1.1)
                gridAllFLRNs = setdiff(gridAllFLRNs, borderRNs);                     % Removes image Border cells from FL cells
                
                % Excluding from "gridAllFLRNs" (and "gridAllFLANs") tracked ANs cells that ONCE were listed as FL BUT that are NOW back AS CORE (3.5)
                gridAllCoreRNs = unique(gridAllCoreRNs);
                gridAllFLRNs = setdiff(gridAllFLRNs, gridAllCoreRNs); % 3.5
                
                % Update of actual FL cell ANs of Grid to track (2.1.0, 3.5):
                gridFLANs = RNs2ANs(gridAllFLRNs, Correspondence); % using "RNs2ANs" (3.5)
                
                gridAllNonBorderRNs = [gridAllCoreRNs ; gridAllFLRNs];
                gridAllBorderRNs = setdiff(cellRNs, gridAllNonBorderRNs);
                
            else % E grid case (3.5)
                for b = 1:nBoxes
                    [ky,kx] = ind2sub([ny nx],b);     % turns linear index b into (i,j) grid coordinate
                    
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    boxRNs = FindBoxRNs(ky, kx, GRID_DEF, cellRNs, cellXYs, scale1D);
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    
                    boxCoreRNs = intersect(boxRNs, coreRNs);
                    boxNonCoreRNs = intersect(boxRNs, nonCoreCells);
                    
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    boxCoreRNsTF = ismember(Correspondence(:,1), boxCoreRNs);
                    boxCoreANs = Correspondence(boxCoreRNsTF, 2:end);
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    
                    gridCoreRNs{ky,kx} = boxCoreRNs;
                    gridCoreANs{ky,kx} = boxCoreANs;
                    gridnCoreRNs(ky,kx) = length(boxCoreRNs);                       % NB: BASED ON NUMBER OF CORE CELLS
                    
                    gridCellBoxYXs(boxCoreRNs,1) = kx;
                    gridCellBoxYXs(boxCoreRNs,2) = ky;
                    
                    % Getting this patch contour indices:
                    boxCellContourIndices = cell2mat(cellContourIndices(boxCoreRNs));
                    otherCellRNs = setdiff(cellRNs, boxCoreRNs);
                    otherCellContourIndices = cell2mat(cellContourIndices(otherCellRNs));
                    boxContourIndices = intersect(boxCellContourIndices, otherCellContourIndices);
                    gridContourIndices{ky,kx} = boxContourIndices;
                    
                    gridAllCoreRNs = [gridAllCoreRNs ; boxCoreRNs]; %#ok<AGROW>
                    
                    gridBoxCellArea(ky,kx) = sum(cellAreas(boxCoreRNs));    % cumulated area of core cells in E OR L box
                    if isempty(boxCoreRNs) || ~isempty(boxNonCoreRNs)       % first checks if box_cell_RNs is empty
                        onlyCoreCellsTF(ky,kx) = false;
                    end
                end
                
                % Only keep numbers once:
                gridAllCoreRNs = unique(gridAllCoreRNs);
                gridAllFLRNs = setdiff(cellRNs, [gridAllCoreRNs ; borderRNs]);  % NB: FL cells are ALL cells but Grid core cells AND image Border cells
                gridAllNonBorderRNs = [gridAllCoreRNs ; gridAllFLRNs];
                gridAllBorderRNs = setdiff(cellRNs, gridAllNonBorderRNs);   % COMMENTED 3.5   
            end
            
        end
        
        %% Definition of AreaRatios %%
        
        if strcmp(gridType,'L') % 3.5
            
            gridMaskTF = logical(gridnCoreRNs);                                         % 0s where no core cells anymore, 1s where 1+ has been found
            gridMaskTF = FindOuterLayers(gridMaskTF, nLayers);                          % peels "nLayers" layers off "gridMaskTF" to make sure to only fully include bulk boxes in calculations
            gridAreaRatios = Normalizer(gridnCoreRNs, gridMaskTF, normalizeMethod);     % renormalizing AreaRatios

        else
            gridMaskTF = onlyCoreCellsTF;                                                   % defining gridMaskTF for Egrid as well (3.5)
            gridAreaRatios = gridBoxCellArea/(boxArea*scale1D^2);
            gridAreaRatios = Normalizer(gridAreaRatios, onlyCoreCellsTF, normalizeMethod);
        end
        
        %% Storage in GRID_CPT and saving Backup (mod 2.14, 3.1) %%
        
        GRID_CPT.CoreRNs = gridCoreRNs;
        GRID_CPT.AllFLRNs = gridAllFLRNs;
        GRID_CPT.AllBorderRNs = gridAllBorderRNs;
        GRID_CPT.CellBoxYXs = gridCellBoxYXs;
        
        % updates written in GRID_CPT:
        GRID_CPT.CoreANs = gridCoreANs;
        GRID_CPT.FLANs = gridFLANs;
        
        % Added in backups (3.1):
        GRID_CPT.ContourIndices = gridContourIndices;
        GRID_CPT.nCoreRNs = gridnCoreRNs;

        GRID_CPT.MaskTF = gridMaskTF;           % saving gridMaskTF for both grids (3.5)
        GRID_CPT.AreaRatios = gridAreaRatios;
        
        if strcmp(gridType,'L') % 3.5
            GRID_CPT.Lcentroids = gridLcentroids;
        end
        
        % passing quantities on to next iteration (2.7)
        cellBNsOld = cellBNs;       % 2.7
        CorrespondenceOld = Correspondence;
        newRNsOld = newRNs;                 % 3.25
        coalescedRNsOld = coalescedRNs;     % 3.25
%         cellNeighborsOld = cellNeighbors;   % 3.31
        
        %%% Saving elements of GRID_CPT in backup file (1.1, 3.0):
        thisFilename = [filenameCPT '_' num2str(n,digitsFormat) '.mat']; % 2.10
        save([backupFolder filesep thisFilename],'-struct','GRID_CPT') % 3.0
        
        % Loading SIA backup if needed (3.20)
        if ((displayNewT1Junctions || displayNewDivJunctions) && n >= newJuncDisplayFrames(1)) || ...
                midlineSymmetry && floor(ny/2) == ny/2  && ~cloneTracking
            
            load(pathSIAbackupFile,'SIDES','CELLS');
            cellContourIndices = CELLS.ContourIndices;
            sideCoupleRNs = SIDES.Cells;
            sideDilatedIndices = SIDES.DilatedIndices;
        end   
        
    else % WHEN backup exists
       
        % NB: Loading backup ONLY if [CPT already exists AND need to make images] OR next backup does NOT exist (3.19)
        if (~exist(CPTimageFilename,'file') && makeCPTimages) || ~exist(nextBackupFile,'file')
            
            fprintf('CPT backup exists and is loading...')
            
            % loading grid backup
            if n == startFrame || ~exist('gridPatchColors','var')
                GRID_DEF = load(pathGridDefFile);
                gridPatchColors = GRID_DEF.PatchColors;
            end
            
            % loading this frame CPT backup
            thisBackup = load(backupFile); % 3.16
            ExtractData(thisBackup,'grid');
            fprintf('Done\n');
            
            % Loading SIA backup if needed (mod 3.31)
            if ((displayNewT1Junctions || displayNewDivJunctions || displayNewDelJunctions) && n >= newJuncDisplayFrames(1)) || ...
                    midlineSymmetry && floor(ny/2) == ny/2  && ~cloneTracking
                
                load(pathSIAbackupFile,'SIDES','CELLS');
                cellContourIndices = CELLS.ContourIndices;
                sideCoupleRNs = SIDES.Cells;
                sideDilatedIndices = SIDES.DilatedIndices;
                % 3.31
                cellNeighbors = CELLS.Neighbors;
            end
            
            % Loding some of this frame quantities to define "OLD" quantities for next iteration (3.19) 
            if ~exist(nextBackupFile,'file')
                
                % Loading "correspondence_XX.txt" file
                CorrespondenceRaw = dlmread([trackingFolder filesep 'correspondence_' num2str(n) '.txt']); %
                Correspondence = FormatCorrespondence(CorrespondenceRaw, nColTotal); 
                clear CorrespondenceRaw;
                
                % Defining "cellBNs"
                cellBoxIs = gridCellBoxYXs(:,2);
                cellBoxJs = gridCellBoxYXs(:,1);
                cellBNs = sub2ind([ny nx], cellBoxIs, cellBoxJs);
                clear cellBoxIs cellBoxJs
                
                % Defining OLD quantities
                cellBNsOld = cellBNs;
%                 CorrespondenceOld = Correspondence; % moved 3.31
                newRNsOld = newRNs;                 % 3.25
                coalescedRNsOld = coalescedRNs;     % 3.25
%                 cellNeighborsOld = cellNeighbors;   % 3.31
            end
            
        elseif exist(CPTimageFilename,'file') || ~makeCPTimages     % skipping iteration if image exist OR no images to make  (3.19)
                     
            disp('CPT backup already exists AND no image to generate: iteration skipped!')
            progressbar(index/nFrames) % updates  progressbar in that case
            disp('---------------------------------------------------------------------------------');
            continue
        end
    end
    
    %% Display (overhaul 3.15, 3.16, 3.34) %%
    
    if (makeCPTimages && ~exist(CPTimageFilename,'file'))... % now checking existence of image before generating it (3.19)
        || n == startFrame || n == finalFrame                % now always saves first and last images (3.24)
    
        fprintf('Generating CPT image...\n')
        
        %%% Creates empty image:
        CPTimageR = zeros(imageSize);
        CPTimageG = zeros(imageSize);
        CPTimageB = zeros(imageSize);
        
        CPTimageR_forcorrection = zeros(imageSize);
        CPTimageG_forcorrection = zeros(imageSize);
        CPTimageB_forcorrection = zeros(imageSize);
        
        
        
        %%% Coloring cells according to box compartment they belong to:
        %%% Creation of CPT correction mask at the same time with other colors (3.34)
        fprintf('   Coloring cells in each compartment...')
        coloredPixelsTF = false(imageSize);
        for b = 1:nBoxes

            [ky,kx] = ind2sub([ny nx],b);                           % turns linear index b into (i,j) grid coordinate (2.7)
            boxCoreRNs = gridCoreRNs{ky,kx};                        %#ok<*USENS>
            boxCorePixelsTF = ismember(segImageLabels, boxCoreRNs);    % binary image of size "imageSize" (2.7)
            boxColor = gridPatchColors{ky,kx};
            
            boxCorePixelIndices = find(boxCorePixelsTF);
            coloredPixelIndices = find(coloredPixelsTF);

            boxColoredPixelIndices = intersect(boxCorePixelIndices, coloredPixelIndices);   % already colored pixels
            boxEmptyPixelIndices = setdiff(boxCorePixelIndices, coloredPixelIndices);       % empty pixels about to be colored
                        
            % Applying color (3.16), (3.34)
            CPTimageR(boxEmptyPixelIndices) = boxColor(1);
            CPTimageG(boxEmptyPixelIndices) = boxColor(2);
            CPTimageB(boxEmptyPixelIndices) = boxColor(3);
            
            % If color is light green, put 
            if boxColor(3) == 1.0 
                CPTimageR_forcorrection(boxEmptyPixelIndices) = round(blue(1));
                CPTimageG_forcorrection(boxEmptyPixelIndices) = round(blue(2));
                CPTimageB_forcorrection(boxEmptyPixelIndices) = round(blue(3));
            end
            
             if boxColor(1) == 0.6 
                CPTimageR_forcorrection(boxEmptyPixelIndices) = round(green(1));
                CPTimageG_forcorrection(boxEmptyPixelIndices) = round(green(2));
                CPTimageB_forcorrection(boxEmptyPixelIndices) = round(green(3));
            end
            

            % Mixing color for pixel already having one (3.16),(3.34)

            CPTimageR(boxColoredPixelIndices) = 0.5*(mean(CPTimageR(boxColoredPixelIndices)) + boxColor(1)); % 3.25
            CPTimageG(boxColoredPixelIndices) = 0.5*(mean(CPTimageG(boxColoredPixelIndices)) + boxColor(2)); % 3.25
            CPTimageB(boxColoredPixelIndices) = 0.5*(mean(CPTimageB(boxColoredPixelIndices)) + boxColor(3)); % 3.25
            
            if boxColor(3) == 1.0 
                CPTimageR_forcorrection(boxColoredPixelIndices) = 0.5*(mean(CPTimageR(boxColoredPixelIndices)) + round(blue(1)));
                CPTimageG_forcorrection(boxColoredPixelIndices) = 0.5*(mean(CPTimageG(boxColoredPixelIndices)) + round(blue(2)));
                CPTimageB_forcorrection(boxColoredPixelIndices) =  0.5*(mean(CPTimageB(boxColoredPixelIndices)) + round(blue(3)));
            end
            
            if boxColor(1) == 0.6 
                CPTimageR_forcorrection(boxColoredPixelIndices) = 0.5*(mean(CPTimageR(boxColoredPixelIndices)) + round(green(1)));
                CPTimageG_forcorrection(boxColoredPixelIndices) = 0.5*(mean(CPTimageG(boxColoredPixelIndices)) + round(green(2)));
                CPTimageB_forcorrection(boxColoredPixelIndices) =  0.5*(mean(CPTimageB(boxColoredPixelIndices)) + round(green(3)));
            end
            
            coloredPixelsTF(boxEmptyPixelIndices) = true; % update: setting formerly empty box pixels to true
        end
        fprintf('Done\n');
        
        fprintf('   Overrididing colors for particular cells & boudaries ...')
        %%% Blending existing colors with "colorNewCells" for new cells:
        if showNewCells
            alltimeNewRNsTF = Correspondence(:,2) > nCells0;                     % finds ANs above nCells0
            alltimeNewRNs = unique(Correspondence(alltimeNewRNsTF,1));               % gets corresponding RNs in this frame
            alltimeNCnewRNs = setdiff(alltimeNewRNs, coalescedRNs);                  % removes coalesced cells
            alltimeNCnewRNsPixelsTF = ismember(segImageLabels, alltimeNCnewRNs);        % directly using imageLabels to find regions
            % Blending existing colors with "colorNewCells" for new cells:
            blendRatio = 0.5; % diluting in half with existing color
            CPTimageR = BlendGray(CPTimageR, alltimeNCnewRNsPixelsTF, colorNewCells(1), blendRatio);
            CPTimageG = BlendGray(CPTimageG, alltimeNCnewRNsPixelsTF, colorNewCells(2), blendRatio);
            CPTimageB = BlendGray(CPTimageB, alltimeNCnewRNsPixelsTF, colorNewCells(3), blendRatio);
            
            CPTimageR_forcorrection = BlendGray(CPTimageR_forcorrection, alltimeNCnewRNsPixelsTF, colorNewCells(1), blendRatio);
            CPTimageG_forcorrection = BlendGray(CPTimageG_forcorrection, alltimeNCnewRNsPixelsTF, colorNewCells(2), blendRatio);
            CPTimageB_forcorrection = BlendGray(CPTimageB_forcorrection, alltimeNCnewRNsPixelsTF, colorNewCells(3), blendRatio);
        end
        
        %%% Overriding colors for apoptotic cells with "colorApoptosis" (overhaul 3.32):
        if showApoptoses
            
            %%% Making delaminating ANs ancestor 3D matrix "ancestorAllDelaminatingANs"
            if n == startFrame
                fprintf('Building "ancestorAllDelANs" 3D matrix to generate CTD images...')
                nDelANs = length(allLastFramesDel);
                ancestorAllDelANs = NaN(nColTotal-1, nDelANs, maxDivisionRound+1);
                ancestorAllDelANs(:,:,1) = allDelaminatingANs'; % initialized with actual delaminating ANs
                for d = 2:maxDivisionRound+1
                    ancestorAllDelANs(:,:,d) = MakeMothers(ancestorAllDelANs(:,:,d-1)')'; % taking mothers at each rounds
                end
                fprintf('Done.\n')
            end
                       
            [ancestorCoreDelRNs, ancestorNonCoreDelRNs] = ...
                DisplayAncestorDelRNs(ancestorAllDelANs,coreDelaminatingLastRNsTF,allLastFramesDel,timeB4Del,Correspondence,nColTotal,n,dt); % 2.25
            
            ancestorCoreDelRNsPixelsTF = ismember(segImageLabels, ancestorCoreDelRNs);   
            ancestorNonCoreDelRNsPixelsTF = ismember(segImageLabels, ancestorNonCoreDelRNs);  
%             apoptoticLastRNsPixelsTF = ismember(segImageLabels, apoptoticLastRNs);
            
            CPTimageR(ancestorCoreDelRNsPixelsTF) = colorApoptosis(1);
            CPTimageG(ancestorCoreDelRNsPixelsTF) = colorApoptosis(2);
            CPTimageB(ancestorCoreDelRNsPixelsTF) = colorApoptosis(3);
            
            CPTimageR_forcorrection(ancestorCoreDelRNsPixelsTF) =  round(yellow(1));
            CPTimageG_forcorrection(ancestorCoreDelRNsPixelsTF) =  round(yellow(2));
            CPTimageB_forcorrection(ancestorCoreDelRNsPixelsTF) =  round(yellow(3));
            
            CPTimageR(ancestorNonCoreDelRNsPixelsTF) = colorApoptosisIssue(1);
            CPTimageG(ancestorNonCoreDelRNsPixelsTF) = colorApoptosisIssue(2);
            CPTimageB(ancestorNonCoreDelRNsPixelsTF) = colorApoptosisIssue(3);
            
            CPTimageR_forcorrection(ancestorNonCoreDelRNsPixelsTF) = colorApoptosisIssue(1);
            CPTimageG_forcorrection(ancestorNonCoreDelRNsPixelsTF) = colorApoptosisIssue(2);
            CPTimageB_forcorrection(ancestorNonCoreDelRNsPixelsTF) = colorApoptosisIssue(3);
        end
        
        %%% Overriding colors for Coalesced cells with "colorFusion":
        if showCoalescedCells
            coalescedRNsPixelsTF = ismember(segImageLabels, coalescedRNs);
            CPTimageR(coalescedRNsPixelsTF) = colorFusion(1);
            CPTimageG(coalescedRNsPixelsTF) = colorFusion(2);
            CPTimageB(coalescedRNsPixelsTF) = colorFusion(3);
            
            CPTimageR_forcorrection(coalescedRNsPixelsTF) = colorFusion(1);
            CPTimageG_forcorrection(coalescedRNsPixelsTF) = colorFusion(2);
            CPTimageB_forcorrection(coalescedRNsPixelsTF) = colorFusion(3);
        end
        
        %%% Coloring FL and border pixel lists:
        FLCpixelsTF = ismember(segImageLabels, gridAllFLRNs);
        blendRatio = 0.8; % diluting with existing color
        CPTimageR = BlendGray(CPTimageR, FLCpixelsTF, colorFLCells(1), blendRatio);
        CPTimageG = BlendGray(CPTimageG, FLCpixelsTF, colorFLCells(2), blendRatio);
        CPTimageB = BlendGray(CPTimageB, FLCpixelsTF, colorFLCells(3), blendRatio);
        
        CPTimageR_forcorrection = BlendGray(CPTimageR_forcorrection, FLCpixelsTF, 0, blendRatio);
        CPTimageG_forcorrection = BlendGray(CPTimageG_forcorrection, FLCpixelsTF, 0, blendRatio);
        CPTimageB_forcorrection = BlendGray(CPTimageB_forcorrection, FLCpixelsTF, 0, blendRatio);
        
        BCpixelsTF = ismember(segImageLabels, gridAllBorderRNs);
        
        CPTimageR(BCpixelsTF) = colorBorderCells(1);
        CPTimageG(BCpixelsTF) = colorBorderCells(2);
        CPTimageB(BCpixelsTF) = colorBorderCells(3);
        
        CPTimageR_forcorrection(BCpixelsTF) = colorBorderCells(1);
        CPTimageG_forcorrection(BCpixelsTF) = colorBorderCells(2);
        CPTimageB_forcorrection(BCpixelsTF) = colorBorderCells(3);
        
        
        %%% Displays grid countour (NOT using "PlotLGrid" that returns a RGB image)
        allGridContourIndices = unique(cell2mat(gridContourIndices(:)));
        allDilatedGridContourIndices = SideDilator(imageSize,allGridContourIndices, 1);
        CPTimageR(allDilatedGridContourIndices) = gridColor(1);
        CPTimageG(allDilatedGridContourIndices) = gridColor(2);
        CPTimageB(allDilatedGridContourIndices) = gridColor(3);
        
        CPTimageR_forcorrection(allDilatedGridContourIndices) = gridColor(1);
        CPTimageG_forcorrection(allDilatedGridContourIndices) = gridColor(2);
        CPTimageB_forcorrection(allDilatedGridContourIndices) = gridColor(3);
        
        %%% If symmetry of colors was chosen AND ny is even, colors boundary (= midline) pixels in pure cyan:
        if midlineSymmetry && floor(ny/2) == ny/2  && ~cloneTracking % ny is EVEN
            
            cellsAbove = cell2mat(reshape(gridCoreRNs(ny/2,:),[],1));
            cellContourIndicesAbove = cell2mat(cellContourIndices(cellsAbove));
            cellsBelow = cell2mat(reshape(gridCoreRNs(ny+1-ny/2,:),[],1));           % ny+1-ny/2 = ny/2
            cellContourIndicesBelow = cell2mat(cellContourIndices(cellsBelow));
            boundaryPixels = intersect(cellContourIndicesAbove,cellContourIndicesBelow);
            boundaryPixels = SideDilator(imageSize, boundaryPixels, 1);               % make boundary line 3 pixels thick
            CPTimageR(boundaryPixels) = cyan(1);
            CPTimageG(boundaryPixels) = cyan(2);
            CPTimageB(boundaryPixels) = cyan(3);
            
            CPTimageR_forcorrection(boundaryPixels) = cyan(1);
            CPTimageG_forcorrection(boundaryPixels) = cyan(2);
            CPTimageB_forcorrection(boundaryPixels) = cyan(3);
        end
        
        %%% Overriding colors for macrochaetes with "colorMacrochaetes"
        macrochaetesPixelsTF = ismember(segImageLabels, macroRNs);                        % directly using imageLabels to find regions
        CPTimageR(macrochaetesPixelsTF) = colorMacrochaetes(1);
        CPTimageG(macrochaetesPixelsTF) = colorMacrochaetes(2);
        CPTimageB(macrochaetesPixelsTF) = colorMacrochaetes(3);
        
        CPTimageR_forcorrection(macrochaetesPixelsTF) = round(custom_yellow(1));
        CPTimageG_forcorrection(macrochaetesPixelsTF) = round(custom_yellow(2));
        CPTimageB_forcorrection(macrochaetesPixelsTF) = round(custom_yellow(3));
        fprintf('Done\n');
        
        % making RGB image (3.16) and CPT correction mask (3.34)
        CPTimage = cat(3,CPTimageR,CPTimageG,CPTimageB);
        CPTimage_forcorrection = cat(3,CPTimageR_forcorrection,CPTimageG_forcorrection,CPTimageB_forcorrection);
        
        
        %%% Coloring NEW junctions
        %----------------------------------------------------------------------------------------------------------
        if (displayNewT1Junctions || displayNewDivJunctions || displayNewDelJunctions) && n >= newJuncDisplayFrames(1) % mod 3.31
            
            fprintf('   Displaying new links (T1 vs Div)...')
            
            % Filling argument structure "cnjARG" for function "ColorNewJunctions" (2.17)
            cnjARG.Correspondence = Correspondence;
            cnjARG.sideCoupleRNs = sideCoupleRNs;
            cnjARG.sideDilatedIndices = sideDilatedIndices;
            
            CPTimage = ColorNewJunctions(CPTimage, cnjARG); % coloring junctions with "ColorNewJunctions" (2.17)
            CPTimage_forcorrection = ColorNewJunctions(CPTimage_forcorrection, cnjARG);
            fprintf('Done\n');
        end
        %----------------------------------------------------------------------------------------------------------
        
        %%% Graphic Display %%
        fig = figure('PaperPositionMode','auto');
%         fig.GraphicsSmoothing = 'off';
        imshow(CPTimage,'Border', 'tight')
        hold on
        
        %%% Display of cell absolute numbers (AN):
        if displayCellNumbers == 1
            cellRNs = unique(Correspondence(:,1));
            nCells = length(cellRNs);
            Xs = cellXYs(:,1)/scale1D; % back to X in pixels (use of scale1D in 2.5)
            Ys = cellXYs(:,2)/scale1D; % use of scale1D (2.5)
            for c = 1:nCells
                if ~ismember(c,borderRNs)
                    rANsTF = ismember(Correspondence(:,1),c);
                    rANs = Correspondence(rANsTF,2);
                    text(Xs(c), Ys(c), num2str(rANs), 'FontSize', fontSizeCellNumbers, 'HorizontalAlignment','center','Color','black','FontWeight', 'bold')
                end
            end
        end

        %%% Plotting info (quantity plotted, time hAPF, animal and scalebar) (2.2):
        textAnimal = '';
        textQuantity = '';
        textTime = '';               % 3.30
        if ~minimalInfoDisplay
            textTime = time;                  % 3.30
            textAnimal = [Animal ' # ' num2str(n)];
            if ~cloneTracking
                textQuantity = 'Patch Tracking';
            else
                textQuantity = 'Clone Tracking'; % 3.1
            end
        end
        PlotInfo(textQuantity, '',0, colorInfo, '{\mu}m', textAnimal, textTime, colorInfo, scaleBarLength, scale1D, fontSizeInfo, xyOffset, scaleBarWidth); % 1.5

        %%% Saving image:
        if makeCPTimages && ~exist(CPTimageFilename,'file') % 3.24
%             CPTimage = insertText(CPTimage,[10,10],textQuantity);
%             imwrite(CPTimage,CPTimageFilename)
%             fig = gcf;
%             fig.PaperPosition = [0 0 32 24];
%             fig.PaperUnits = 'inches';
            print(printFormat, printResolution, CPTimageFilename) % 3.19
        end
        
       % Save CPT correction mask if clone tracking (3.34)
        if cloneTracking
            if exist(pathFolderTMP,'dir') == 0
                mkdir(pathFolderTMP);
            end
            pathCPTimage_forcorrection = [pathFolderGUI filesep 'maskCPT_'];
            if exist(pathCPTimage_forcorrection,'dir') == 0                
               mkdir(pathCPTimage_forcorrection);
            end
            path2CPTimage_forcorrection = ['maskCPT_' Animal '_' num2str(n, digitsFormat) '.' imageFormatOutput];
            imwrite(CPTimage_forcorrection, [pathFolderGUI filesep 'maskCPT_' filesep path2CPTimage_forcorrection]);   % (3.34) 
        end 
        
        % ALWAYS save first and last images in CPT parent folder (3.24)
        if n == startFrame || n == finalFrame
            print(printFormat, printResolution, [gridFolderCPT filesep CPTimageFilenameShort]) % 3.19

            % Printing version with grid/clone compartment numbers (3.29)
            %-----------------------------------------------------------------------------------------
            [I,J] = ind2sub(GRID_DEF.Size, (1:nBoxes)');
            IJtext = [repmat('[',nBoxes,1) num2str(I) repmat(',',nBoxes,1) num2str(J) repmat(']',nBoxes,1)];
            
            % finding empty locations to remove
            keepBoxesLoc = find(gridnCoreRNs); % boxes with >1 cell
            
            if strcmp(gridType,'L') % 3.32
                LcentroidsCrop = gridLcentroids(keepBoxesLoc);
            else % eulerian case (3.32)
                LcentroidsCrop = GRID_DEF.Centroids;
                LcentroidsCrop = LcentroidsCrop(:);
                LcentroidsCrop = LcentroidsCrop(keepBoxesLoc);
            end
            LcentroidsCrop = cell2mat(LcentroidsCrop);
            IJtextCrop = IJtext(keepBoxesLoc,:);
            text(LcentroidsCrop(:,1), LcentroidsCrop(:,2), IJtextCrop, 'HorizontalAlignment','center','VerticalAlignment','top', 'Color', gridNumberColor,'FontWeight','bold');
            
            % adding grid COORDINATES (3.33)
            if ~cloneTracking
                gridXYs = gridDefBU.Coordinates;
                gridXYs = gridXYs(:); % puts everything in a column (=> matching linear indices)
                gridXYsMat = cell2mat(gridXYs);
                XYtext = [repmat('[',nBoxes,1) num2str(gridXYsMat(:,1)) repmat(',',nBoxes,1) num2str(gridXYsMat(:,2)) repmat(']',nBoxes,1)];
                XYtextCrop = XYtext(keepBoxesLoc,:);
                
%                 text(LcentroidsCrop(:,1), LcentroidsCrop(:,2), IJtextCrop, 'HorizontalAlignment','center','VerticalAlignment','top', 'Color', gridNumberColor,'FontWeight','bold');
                text(LcentroidsCrop(:,1), LcentroidsCrop(:,2), XYtextCrop, 'HorizontalAlignment','center','VerticalAlignment','bottom', 'Color', gridNumberColor,'FontWeight','bold'); % (3.33)
            end
            print(printFormat, printResolution, [gridFolderCPT filesep 'boxXYs&IJs_' CPTimageFilenameShort]) % 3.19,  "boxNs_" became  "boxXYs&IJs_" (3.33)
            %-----------------------------------------------------------------------------------------
            
            
           
        end
        close
        fprintf('Done\n');
    else
        disp('Image already exists and has not been re-generated!')
    end
    
    disp('---------------------------------------------------------------------------------');
    
    
    %% Progressbar update %%
    
    progressbar(index/nFrames)
    
end

%% History %%

% FUTURE IMPROVEMENTS:
%-----------------------------------------------------------------------------------------------------------------------
% - UPDATE GLOBAL STATS: rose plots on a grid, reproduce Ds map, new Ds_bridges map, patch deformation
% - define squares (at startFrame) that will deform over time: estimate gradU out of it and compare to G
% *** WARNING ***
% - right now "cellBNs" ONLY indicates the LAST box that was iterated (because it overwrites the previous box number)
% => new cells (AND back-tracked A/D cells when not using gridTime = 'start') are assigned based on this number and
% therefore ONLY belong to the last iterated box when they should often be listed in several compartments.
% - when displaying patches, upgrades "cellBNs" so it can list all boxes each cell belong to => then can use the mix of
% the colors assigned to boxes to color cells accordingly
% - Improve midline display and evolution by specifically tracking cells at the interface, independantly of grid compartments
% - allow more than 1 type of clone (=> increase number of columns)
% - since study of interface between clones and WT is relevant => isolate sub-category of cells lying at the interfaces
% to calculate some statistics on them.
% - FIGURE OUT WHY SOME CELLS DISAPPEARING IN THE BORDER REGION ARE STILL NOT EXCLUDED AT THE BEGINNING WHEN
% excludeLostCells = 1
%-----------------------------------------------------------------------------------------------------------------------

% 24/09/2020: 3.34 (Lucas)
% - Creation of new frames output for Correction Interface, to see
% clones and symetrics 

% 31/01/2020: 3.33
% - "boxNs_" images became "boxXYs&IJs_", thereby adding display of grid
% COORDINATES on top of already displayed grid IJs.

% 05/04/2019: 3.32
% - doing a crop before using "cell2mat" is because one gets a
% weird bug when concatenating EMPTY compartment of different
% sizes!! (1x0 vs 0x0!!)
% - fixed bug when trying to display compartment coordinates with eulerian grid
% - now displays delaminating with function "DisplayAncestorDelRNs" the same
% way they are displayed in "CellTrackingDisplay"

% 01-03/04/2019: 3.31
% - now displays new junctions created by delaminations (now
% loading new junction CTD backup that contains newDivCouplesTF,
% newDelCouplesTF, newT1CouplesTF).

% 26/03/2019: 3.30
% - stopped displaying time in "minimalInfoDisplay" mode

% 25/01/2019: 3.29
% - now adding grid/clone compartment numbers on patch/clone image to
% better know which one to select in following analysis.

% 02/11/2018: 3.28
% - reverted 3.26 change: clone parts remain separated to be able to track
% several clone parts simultaneously
% - introduced parameter "nCellsMin" to discard clone parts containing few
% cells.
% - added "gridFrameCellContourIndices" and "nCellsMin" as arguments of
% function "FilterCloneImageLabels".

% 24/07/2018: 3.27
% - now removing isolated single cells completely detached from the other
% cells making up cell patches.

% 26/06/2018: 3.26
% - now ALL clone parts are gathered into ONE SINGLE compartment grid
% => only looking at cells belonging to any clone part.

% 19/06/2018: 3.25
% - fixed issue where new cells were erraticly assigned to tracked boxes. To do so:
% - now excluding cells that were new and coalesced in previous frame from "cNeighborRNsOld" list
% - now only assigns a box to a new cells when it has 3+ neighbors with the
% same assigned box.
% - fixed mixing of color when a patch already has an assigned color
%
% 07/06/2018: 3.24
% - stopped applying "excludeLostCells" when running Eulerian grid
% - now loading grid defined in "SAP_parameters"
% - now always saves 1st and last images of patches (regardless of "makeCPTimages")
% - removed commented part related to "ROIcrop"

% 18/05/2018: 3.23
% - removed parameter "invertCloneMask"
% - commented part related to "ROIcrop"

% 04/05/2018: 3.22
% - use of "GetCellCategories" to extract "coreRNs", "FLRNs", "borderRNs"

% 26/03/2018: 3.21
% - fixed the remaining "histc" bugs (was crashing when looking among only
% NaNs) in the part reassigning cells detached from patch to box in start
% frame.
% - only using "histc" now (and not "hist"), a function that nevertheless
% will become obsolete.

% 13/03/2018: 3.20
% - now directly determining "nCells0" using function "GetnCells0".
% - fixed bug when displaying new junctions without existing backups.

% 07/02/2018: 3.19
% - fixed the "histc" bug when new RNs need to be assigned to grid
% compartments based on the boxes their neighbor belong to.
% - now skipping backup and/or image generation when CPT backup and/or
% image is found. To do this, need to load nth backup when (n+1)th backup
% does NOT exist to define old quantities.

% 31/01/2018: 3.18
% - small adjustments to run with new function and variable names
% - reinitialization of "macroRNs" as [] default

% 15/12/2017: 3.17
% - now possible to crop clone (and its wT counterpart) to a ROI defined by the CPT backup of a single patch
% (parameters "ROIcrop" in AIA_parameters and "ROIgrid" in each animal AIA_info).

% 13/12/2017: 3.16
% - now loads backups when they exist to replot images without recalculating anything
% - if user asked to plot images whereas last backup AND image exist => skipping execution
% - stopped using "Paint" and "BlendGray" in the loop over grid compartments because taking way too long to produce an
% image => stopped using RGB image CPTimage in favor of its version with 3 separate RGB layers CPTimageR/G/B
% - fixed crash because "cellContourIndices" was not loaded when reloading CPT backups

% 12/12/2017: 3.15
% - now supports display of newly formed junctions by loading CTD "allNewJunctions.mat" backup file by setting
% parameters "displayNewT1/DivJunctions" to true
% - stopped using function "CPTdisplay"
% - possibility to use a single color for ALL box compartments
% - moved out determination of "nCells0Used" to "AIA_parameters"
% - fixed issue when skipping execution because all backup already exists but user still want to generate images

% 29/11/2017: 3.14
% - adjustments for new version of "MakeDaughters" 2.0+ that separates daughters ANs 1 & 2 into two vectors
% - erased long commented part "Global statistics over patches": those statistics must be done in AOS
% - removed loading of "dividingRNs" from tracking txt file that was NOT used
% - stopped loading "apoptoticRNs" from tracking txt file but rather use CTD backup quantities.

% 13/10/2017: 3.13
% - use of functions "GetImageLabels", "macroANs2macroRNs" and "FindMacroANs"
% - CppTD became CTD

% 25/09/2017: 3.12
% - added option "includeNewCells" that enables to NOT include newly appeared cells when performing cloneTracking
% - moved the saving of clone/grid image to AIA parameters, right after grid validation
% - accordingly moved creation of "pathFolderCPT", "gridFolderCPT" to AIA_parameters

% 19/09/2017: 3.11
% - reverted the support of old naming of SIA backup files (that must now be overwritten by re-running SIA)

% 15/09/2017: 3.10
% - added a level (2) of filtering of lost cells: excluding cells in start frame that will loose 1+ daughter
% - added value of "excludeLostCells" in the txt file

% 14/09/2017: 3.9
% - filtering of lost cells level 1: removing lost cells but keeping mothers having 1+ daughter in final image
% - new parameter "excludeLostCells"

% 14/09/2017: 3.8
% - fixed issue with "macroRNs" that could contain border cells such as the border region when a macrochaetae fuses with
% it, thereby making it yellow
% - probably also fixed other related issue when some macroANs get lost in the process (cf. macroRNsFound in CppTrackingDisplay)
% - compatibility with old and new SIA backups

% 07/09/2017: 3.7
% - now loads "macroANs" from CppTD backup "macroCells.mat" (when found)
% - excludes those macrochaetaes from the list of RNs listed in box compartments => will be excluded from subsequent
% analyses AOS, TA...
% - display them in yellow

% 06/09/2017: 3.6
% - now also supports simple tracking of clones without WT counterparts when "matchingWTclone" = false OR yMid is EMPTY
% - accordingly introduced "matchingWTclone" as new argument
% - set constant colors for WT and clone parts, using parameters colorWT and colorClone defined in AIA_parameters
% - NB: no need to further specify folder name according to matchingWTclone value because grid sizes are nyx1 when false
% and nyx2 when true

% 28/07/2017: 3.5
% - support of EULERIAN Grids so cell patches are defined once and for all by this program, and this program ONLY
% - accordingly saves grid folders with names starting with "LGrid_..." or "EGrid_..." or "Clone_"
% - saving "MaskTF" for E grid as well
% - loading existing patch colors from GridDef backup when it exists AND when "keepPatchColors" is true
% - extensively using "RNs2ANs" and "ANs2RNs"
% - LGrid mode, now properly excluding from gridAllFLRNs and gridAllFLANs the coreRNs corresponding to cells being
% tracked in compartments, thereby properly re-integrating them when they are back as core cells in image (used to be
% incoherently listed as grid core AND gridALLFLANs/RNs)
% - removed "PIVgridUsed" from CPT folder and file names (in AIA_parameters), but added it to txt files listing
% parameters used
% - now saving "GridDef" mat file apart in grid parent folder (and not in "backupFolder" anymore)
% - skips CPT execution if last backup is found

% 28/07/2017: 3.4
% - removed resume mode that unecessarily complicates the code
% - accordingly removed CPT parameters "resume_CPT" and "nResume" in "AIA_parameters"

% 25/07/2017: 3.3 BECAME "CellPatchTracking"; working with LGrid
% - now defining grid in "AIA_parameters"
% - now defining "maxDivisionRound" and "nColTotal" in "AIA_parameters"
% - when determining clone, now using "gridFrameBorderRNs" and "gridImageLabels"
% - fixed issue with saving "this_grid" image

%-----------------------------------------------------------------------------------------------------------------------
% NB: "LagrangianPatchTracking" (3.2) BECAME "CellPatchTracking" (3.3)
%-----------------------------------------------------------------------------------------------------------------------

% 20/07/2017: 3.2 ** CLONE TRACKING IS FUNCTIONAL **
% - Support of the tracking of clones AND its WT counterparts (symmetric % to the midline) when available: will store all
% clone regions based on specified binary clone mask (corresponding to gridTime). IN FIRST COLUMN OF BACKUP QUANTITIES,
% will find the clone related data, and IN SECOND COLUMNS, the matching WT related data (for comparison with clone)

% 19/07/2017: 3.1
% - moved ALL constant values defining grids into GridDef backup
% - parameter "makeLPTimages"
% - added in backups everything required to run TA, AOS... (Lcentroids, CoreRNs, ContourIndices...)
% - removed some quantities from backups

% 20/07/2017: 3.0 BECAME "LagrangianPatchTracking"
% - removing structure layer of backups (Grid_LG and Grid_DEF)
% - fixed resume mode (reusing patch colors) and starting from "nResume"
